---
layout: single
title: "트랜잭션 이해"
categories: [db1]
tags: [db1, TIL]
toc: true
author_profile: true
sidebar:
  nav: "docs"
---

# ☕ Spring 공부 기록

## 📘 학습 날짜
- 2025-08-01

## 📅 오늘 배운 내용

### ✨1. 트랜잭션 개념 이해(3학년 1학기 데이터베이스 수업에서 학습 완료)

- 하나의 거래를 안전하게 처리하도록 보장해주는 것
- 데이터 베이스에 정상 반영(Commit) , 되돌리기 (Rollback)
- **ACID (트랜잭션의 4대 속성)**

    - **원자성(Atomicity)**
      트랜잭션 내의 작업은 모두 성공하거나 모두 실패해야 함 (All or Nothing)

    - **일관성(Consistency)**  
      트랜잭션 실행 전과 후의 DB 상태는 항상 유효한 제약 조건을 만족해야 함

    - **격리성(Isolation)**  
      동시에 실행되는 트랜잭션이 서로 간섭하지 않도록 독립적으로 실행되어야 함

    - **지속성(Durability)**  
      트랜잭션이 성공적으로 완료되면, 그 결과는 시스템 장애가 발생해도 유지되어야 함

---
### ✨2. 데이터베이스 연결 구조와 DB세션

- 사용자는 WAS나 DB 접근 툴 같은 클라이언트 사용하여 데이터베이스 서버 접근 가능
- 클라이언트는 데이터베이스 서버에 연결 요청 및 커넥션 맺음
- 데이터베이스 서버는 내부에 세션 생성, 앞으로 커넥션을 통한 모든 요청은 이 세션을 통해서 실행
- 세션은 트랜잭션 시작 및 커밋, 롤백 통해 트랜잭션 종료함
- 커넥션 풀이 10개의 커넥션 생성하면 세션도 10개 생성됨
---
### ✨3. 트랜잭션 예제

- 강의 보면서 실습 완료
- 자동 커밋과 수동 커밋만 정리
- **자동커밋** : 각각의 쿼리 실행 직후 자동으로 커밋 호출하기때문에 커밋,롤백 직접 호출하지 않아도 되는 편리함이 있다. 하지만 자동으로 커밋 되어버리기 대문에 트랜잭션 기능 제대로 사용할 . 없음.
- **수동커밋** : set autocommit false , 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현할 수 있다.
---
### ✨4. DB 락

- 세션이 트랜잭션 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 막아야함.
- 세션 1이 쿼리를 수행하고 commit을 안했다면 그 row에 대해서는 락 가지고 있음. 
- 이때 세션2가 그 row에 대해 접근한다면 해당 row에 락을 획득해야 하므로, 락이 돌아올 때 까지 대기함. (대기시간 설정 가능)
- 세션 1이 커밋하면 세션2가 락 획득하고 접근 하여 쿼리 수행
---
#### 4-1. DB 락 - 조회

- 일반적인 조회는 락을 사용하지 않는다.
- 하지만 데이터를 조회할 때도 락을 획득하고 싶다면? (데이터를 먼저 읽어보고 확인한 뒤, 매우 중요한 계산 수행 로직, 어디에서도 데이터를 변경하지 않아야 된다면)
- 먼저 그 데이터를 선점하는 용도
- select for update 구문 사용
- set autocommit false -> select * from member where member_id ='memberA' for update;

### ✨5. 궁금했던점

- 그럼 왜 굳이 select for update 구문을 사용하나? 그냥 update문을 사용해도 커밋 전까지 그 데이터에 대해 락걸리는건 같은데? 
- 이에 대한 정리

---
### 🔒 UPDATE vs SELECT FOR UPDATE 차이 정리

#### ✅ 목적 차이

| 구분 | `UPDATE` | `SELECT FOR UPDATE` |
|------|----------|----------------------|
| 기본 목적 | 값을 즉시 수정 | 읽고 계산 후 수정 (락 선점) |
| 락 종류 | row-level write lock | row-level exclusive lock (read + write) |
| 비즈니스 로직 개입 | 불가능하거나 어려움 | Java 코드 등에서 가능 |
| 성능 | 빠름 | 상대적으로 느림 |
| 정확성 | 단순한 경우 충분 | 복잡한 조건 제어 가능 |

---

#### 💡 왜 `SELECT FOR UPDATE`를 쓰는가?

- 데이터를 **먼저 조회하고**, **Java에서 조건 검증 후**, **수정**하는 구조를 만들기 위해
- 동시에 여러 사용자가 접근해도 **내 트랜잭션이 데이터를 먼저 선점하도록** 하기 위해

---

#### 📌 재고 예시

#### 📍 1. `UPDATE`만 사용하는 경우

```sql
UPDATE item SET stock = stock - 1 
WHERE item_id = 1 AND stock >= 1;
```
- 단순하고 빠름

- 동시에 두 요청이 들어오면 둘 다 stock >= 1 조건을 통과할 수 있음

- 결국 stock이 -1로 내려갈 수 있음 (락/격리 수준에 따라)

#### 📍 2. `SELECT FOR UPDATE` 사용하는 경우

```sql
BEGIN;
SELECT * FROM item WHERE item_id = 1 FOR UPDATE;
-- 락이 걸려서 다른 트랜잭션은 이 row에 접근 불가

-- Java 코드에서 stock >= 1 조건 확인
UPDATE item SET stock = stock - 1 WHERE item_id = 1;
COMMIT;
```

- 락을 선점해 두고 계산 후 수정

- 조건을 만족하지 않으면 ROLLBACK

- 정밀한 제어가 가능, 실무에서 안전한 방식

