---
layout: single
title: "자바 예외 이해"
categories: [db1]
tags: [db1, TIL]
toc: true
author_profile: true
---

# ☕ Spring 공부 기록

## 📘 학습 날짜
- 2025-08

## 📅 오늘 배운 내용

### ✨ 1. 자바 예외 계층 설명

1. Object : 자바의 모든 객체의 최상위 부모는 Object다. 그러므로 예외의 최상위 부모도 Object이다.
2. Throwable : 최상위 예외이고, 그 밑에 Error와 Exception이 있다.
3. Error : 이 예외 메모리 부족, 시스템 오류 등 애플리케이션 내에서 해결할 수 없는 예외이다. 개발자는 이 예외를 잡으려고 해서는 안된다.<br> 상위 예외를 catch로 잡으면 그 하위 예외까지 잡는다. 애플리케이션 로직에서는 그로인해 Throwable 예외를 잡으면 안되는데, 그 이유는 그 하위 예외인 Error 예외까지 잡을 수 있기 때문이다.
4. Exception : 체크예외 
   - 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외이다. 
   - Exception과 그 하위 예외(SQLException, IOException)는 모두 컴파일러가 체크하는 체크 예외이다. 다만 RuntimeException은 언체크예외로 제외한다.
5.  RuntimeException : 언체크예외, 런타임 예외
    - 컴파일러가 체크하지 않는 언체크 예외이다.
    - RuntimeException 과 그 자식 예외(NullPointerException, IllegalArgumentException)는 모두 언체크 예외이다.

### ✨ 2. 예외 기본 규칙

- 예외는 잡아서 처리하거나, 처리하지 못하면 던져야한다.
- 예외를 잡거나 던지면, 지정한 예외뿐만이 아닌, 그 자식 예외들까지 함께 처리된다.
- 예외 처리 기본 흐름
    - 정상흐름 - Controller(처리) - service(던짐) - repository(예외발생, 던짐)
  

**예외를 처리하지 못하고 계속 던지면?**
- 계속 던져져서 자바 main() 스레드까지 던져졌다면, 예외 로그를 출력하면서 시스템을 종료한다.
- 웹 애플리케이션의 경우에는 여러 사용자와 응답을 주고받고 있기 때문에, 시스템이 종료되면 안된다. 그러므로 WAS가 해당 예외를 받아서 처리하는데, 주로 사용자에게 개발자가 지정한 오류 페이지를 보여준다.

### ✨ 3. 체크 예외 기본 이해(예제 코드는 github에)

- Exception과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다.(RuntimeException은 예외)
- 체크예외는 잡아서 처리하거나, 밖으로 던지지 않는다면 컴파일 오류가 발생한다.
- Exception을 상속받는 예외는 체크 예외가 된다.
- RuntimeException을 상속받으면 언체크 예외가 된다.
- 체크 예외를 잡아서 처리하려면 catch 사용. catch(Exception e) 라고 한다면 그 하위 타입 예외를 모두 잡아준다.
- 체크예외를 밖으로 던지지 않으면 컴파일 오류 발생

**체크 예외 장단점**

- 장점 : 개발자가 실수로 예외를 누락하지 않도록 컴파일러가 잡아주기 때문에 안전장치 역할 가능
- 단점 : 개발자가 모든 체크 예외들을 잡거나 던져야하므로 번거롭고, 신경쓰고싶지 않은 예외까지 모두 챙겨야함.


### ✨ 4. 언체크 예외 기본 이해

- RuntimeException과 그 하위 예외는 언체크 예외로 분류
- 컴파일러가 예외 체크 안하는 예외이다.
- 예외를 던지는 throws를 생략할 수 있고, 이 경우 자동으로 예외 던짐.

**체크예외 vs 언체크예외**
- 체크예외는 예외 잡아서 처리하지 않는다면 thorws로 항상 예외를 던져야함.
- 언체크 예외는 예외를 잡아서 처리하지 않아도 throws 생략 가능
- 예외를 처리할 수 없을 때 이부분 throws로 예외를 던지는 부분을 필수로 선언해야 하는가 생략할 수 있는가의 차이


**언체크 예외의 장단점**

- 장점 : 신경쓰고 싶지 않은 예외를 무시할 수 있다. 신경쓰고 싶지 않은 예외의 의존관계를 참조하지 않아도 된다.
- 단점 : 개발자가 실수로 예외 누락 가능

### ✨ 5. 체크 예외 활용

그렇다면 언제 체크 예외를 사용하고 언제 언체크 예외를 사용하면 좋나?

**기본 원칙**
- 기본적으로 언체크 예외를 사용
- 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용
  - 이 경우 해당 예외를 잡아서 반드시 처리해야 하는 문제일 때만 체크예외 사용
  - 예를 들어 계좌 이체 실패 예외, 결제시 포인트 부족 예외, 로그인 ID,PW 불일치 예외
- 이 경우에도 100% 체크예외로 만들어야 되는건 아니지만, 개발자가 실수로 예외를 놓치면 심각한 문제가 발생하는 로직에서는 컴파일러를 통해 놓친 예외 인지 가능


**체크 예외의 문제점**
시나리오를 통해 이해해보자.

- repository는 DB에 접근해서 데이터를 저장하고 관리한다. 여기서 SQLException 체크 예외를 던진다.
- NetworkClient 객체에서도 ConnectException 체크 예외를 던진다.
- 서비스는 repository와 NetworkClient 둘 다 호출한다. 
  - 두 곳에서 올라오는 SQLException, ConnectException 처리해야 하는데, 서비스는 이 둘을 처리할 방법을 모른다.
  - 연결 실패, 데이터베이스에서 발생하는 문제처럼 심각한 문제들은 대부분 애플리케이션 로직에서 처리 할 방법 없음.
  - 둘다 밖으로 던져야한다. (method() throws SQLException, ConnectException)
- 컨트롤러도 마찬가지로 예외를 처리할 방법이 없다. 또 던진다.
- 웹 애플리케이션은 서블릿의 오류페이지나, 스프링 MVC가 제공하는 ControllerAdvice에서 이런 예외 공통 처리한다.
  - 이런 문제는 사용자에게 자세히 설명하기 어렵기 때문에, 일반적인 메시지를 보여준다.
  - API라면 HTTP 상태코드 500(내부 서버 오류)을 사용해서 응답을 내려준다.
  - 이렇게 해결이 불가능한 공통 예외는 오류 로그를 남기고, 개발자가 오류를 빨리 인지할 수 있도록 메일, 알림 등을 통해 전달받아야한다.

이렇듯 2가지 문제가 발생한다
1. 복구 불가능한 예외
    - 대부분의 예외는 복구가 불가능하다. 
    - SQLException을 예로 든다면, 데이터베이스에 무언가 문제가 있어서 발생하는 예외이다.(문법 오류나, 데이터베이스 자체 문제) 이런 문제는 대부분 서비스나 컨트롤러에서 대부분 해결 불가능. 
    - 이런 문제는 일관성 있게 공통으로 처리해야한다. 오류 로그를 남기고, 서블릿 필터, 스프링 인터셉터, 스프링의 ControllerAdvice를 사용하여 깔끔하게 공통으로 해결 가능하다.
   
2. 의존관계에 대한 문제
    - 서비스 컨트롤러에서 java.sql.SQLException을 의존하게 된다.
    - 향후 repository를 JDBC기술이 아닌 다른 기술로 변경하여서, JPAException으로 예외가 변경되면, 모든 서비스, 컨트롤러의 코드를 JPAException에 의존하도록 고쳐야한다. 
    - 서비스나 컨트롤러 입장에서는 본인이 처리할 수 없는 예외에 의존해야 하고, 이는 OCP, DI를 통해 클라이언트 코드의 변경 없이 대상 구현체를 변경할 수 있다는 장점이 체크 예외 무너지게 된다.

**추가**
- Exception은 던지지 않아야한다. 
- 그 이유는 Exception은 최상위 타입이므로 모든 체크 예외를 다 밖으로 던지는 문제가 발생하게 되고, 중요한 체크 예외를 다 놓치게 된다.


### ✨ 6. 언체크 예외 활용

- SQLException이 발생하면 RuntimeSQLException으로 변환하여 예외를 던진다.
- 이때 기존 예외를 포함해주어야 예외 출력 시 스택 트레이스에서 기존 예외도 함께 확인 가능.
- 시스템에서 발생한 예외는 대부분 복구 불가능 예외이다.
- 런타임 예외를 사용하면, 서비스나 컨트롤러가 이런 복구 불가능한 예외를 신경쓰지 않아도 된다. 더하여 이런 복구 불가능한 예외는 일관성 있게 공통처리 해야한다.
- 런타임 예외는 해당 객체가 처리할 수 없는 예외는 무시하므로, 예외를 강제로 의존하지 않아도 된다.
- 구현 기술을 변경하는 경우 공통 처리 하는 곳만 변경하면 되기 때문에, 변경의 영향 범위 최소화

### ✨ 7. 예외 포함과 스택 트레이스 

**예외를 전환할 때에는 꼭 기존 예외를 포함하자. 그렇지 않으면, 스택 트레이스를 확인할 때 심각한 문제가 발생한다.**

기존 예외 포함하는 경우
```java
public void call() {
    try {
        runSQL();
    } catch (SQLException e) {
        throw new RuntimeSQLException(e); //기존 예외(e) 포함
    }
}
```

출력 로그에 예외를 포함하여, 기존에 발생한 java.sql.SQLException과 스택 트레이스 확인 가능하다.

포함하지 않는 경우
```java
public void call() {
    try {
        runSQL();
    } catch (SQLException e) {
        throw new RuntimeSQLException(); //기존 예외(e) 제외
    }
}
```

예외를 포함하지 않아서 기존에 발생한 java.sql.SQLException과 스택 트레이스를 확인할 수 없다. 만약 DB와 연동했다면, DB에서 발생한 예외를 확인할 수 없는 심각한 문제가 발생한다.




