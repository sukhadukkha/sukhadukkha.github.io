---
layout: single
title: "고급 매핑 정리"
categories: [jpa]
tags: [jpa, TIL]
toc: true
author_profile: true
sidebar:
  nav: "docs"
---

# 고급 매핑 (JPA)

## 목차
1. 상속관계 매핑
2. `@MappedSuperclass`
3. 실전 예제 - 상속관계 매핑

---

## 1. 상속관계 매핑

- 관계형 DB는 **상속 개념 없음**
- 대신 **슈퍼타입/서브타입 관계 모델링** 기법이 객체 상속과 유사
- JPA는 객체 상속 구조 ↔ DB 슈퍼타입-서브타입 관계 매핑 지원

### 물리 모델 변환 전략
1. **조인 전략 (JOINED)** → 각 클래스마다 테이블 생성, 조인으로 조회
2. **단일 테이블 전략 (SINGLE_TABLE)** → 하나의 테이블에 모두 저장
3. **구현 클래스마다 테이블 전략 (TABLE_PER_CLASS)** → 자식 클래스별 독립 테이블

### 주요 어노테이션
```java
@Inheritance(strategy = InheritanceType.XXX)
@DiscriminatorColumn(name = "DTYPE")
@DiscriminatorValue("XXX")
```
- `JOINED`, `SINGLE_TABLE`, `TABLE_PER_CLASS` 선택 가능

---

## 2. 상속 매핑 전략 비교

### (1) 조인 전략
**장점**
- 테이블 정규화
- FK 참조 무결성 보장
- 저장 공간 효율적

**단점**
- 조회 시 조인 많아 성능 저하
- SQL 복잡
- INSERT 시 SQL 2번 실행

---

### (2) 단일 테이블 전략
**장점**
- 조인 없음 → 조회 성능 빠름
- SQL 단순

**단점**
- 자식 엔티티 컬럼 `NULL` 허용 필요
- 테이블 비대화 가능, 경우에 따라 성능 저하

---

### (3) 구현 클래스마다 테이블 전략
**추천하지 않음** (DB 설계자/ORM 전문가 모두 비권장)

**장점**
- 서브타입 구분 명확
- `NOT NULL` 제약조건 가능

**단점**
- 여러 자식 조회 시 `UNION` 필요 → 성능 저하
- 통합 쿼리 어렵다

---

## 3. `@MappedSuperclass`

- **공통 매핑 정보 제공용** (예: id, name, 등록일, 수정일 등)
- 엔티티 아님 → 테이블과 매핑 ❌
- 자식 클래스에 매핑 정보만 상속
- `em.find(BaseEntity)` 불가
- 추상 클래스 권장

**용도**
- 엔티티 공통 속성(등록일, 수정일, 등록자 등) 관리
- `@Entity` 또는 `@MappedSuperclass` 로 지정된 클래스만 상속 가능

---

## 4. 실전 예제

### 요구사항
- 상품의 종류: 음반, 도서, 영화 (확장 가능)
- 모든 데이터는 등록일과 수정일 필수

### 구현 방법
- `Item` (부모 엔티티)
    - 공통 속성 (id, name, price, 등록일, 수정일 등)
- `Album`, `Book`, `Movie` (자식 엔티티)
- `@Inheritance(strategy=...)` 로 전략 선택
- 공통 속성은 `@MappedSuperclass` 로 관리  
