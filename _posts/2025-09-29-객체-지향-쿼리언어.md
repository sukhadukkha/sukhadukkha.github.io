---
layout: single
title: "객체 지향 쿼리언어"
categories: [jpa]
tags: [jpa, TIL]
toc: true
author_profile: true
---

# 객체지향 쿼리 언어 (JPQL) 상세 정리

## 목차

1. 객체지향 쿼리 언어 소개
2. JPQL 기본 문법과 특징
3. Criteria 소개
4. QueryDSL 소개
5. 네이티브 SQL & JDBC 직접 사용
6. JPQL 문법 세부 사항
7. 집합과 정렬
8. 결과 조회 API
9. 파라미터 바인딩
10. 프로젝션
11. 페이징 API
12. 조인과 서브쿼리
13. 조건식과 함수
14. 경로 표현식
15. 페치 조인
16. 다형성 쿼리
17. 엔티티 직접 사용
18. Named 쿼리
19. 벌크 연산

---

## 1. 객체지향 쿼리 언어 소개

* JPA는 다양한 데이터 조회 방식을 제공:

    * **JPQL** (객체지향 쿼리 언어)
    * Criteria
    * QueryDSL
    * 네이티브 SQL
    * JDBC API, MyBatis, SpringJdbcTemplate 등
* **JPQL**은 SQL을 추상화하여 엔티티 객체를 대상으로 작성.
* SQL은 테이블 기반, JPQL은 엔티티 기반.
* 즉, JPQL은 데이터베이스 테이블이 아니라 **객체 모델을 탐색**하는 쿼리 언어.

---

## 2. JPQL 기본 문법과 특징

* **기본 문법**은 SQL과 유사:

    * `SELECT`, `FROM`, `WHERE`, `GROUP BY`, `HAVING`, `ORDER BY`, `JOIN`
* **엔티티와 속성**은 대소문자 구분 (예: `Member`, `age`)
* **JPQL 키워드**는 대소문자 구분 없음 (예: `SELECT`, `FROM`)
* 별칭 필수 (예: `SELECT m FROM Member m`)
* 실행 예시:

  ```java
  String jpql = "select m from Member m where m.age > 18";
  List<Member> result = em.createQuery(jpql, Member.class).getResultList();
  ```

---

## 3. Criteria 소개

* JPQL을 자바 코드로 작성할 수 있는 API.
* 장점:

    * 동적 쿼리 작성 용이.
    * IDE 자동완성 지원.
* 단점:

    * 코드가 복잡하고 가독성 낮음.
* **실무에서는 QueryDSL 사용을 권장.**

---

## 4. QueryDSL 소개

* JPQL 빌더 역할을 하는 오픈소스 프레임워크.
* 장점:

    * 문법 오류를 컴파일 시점에 검출 가능.
    * IDE 자동완성 지원.
    * 동적 쿼리 작성 편리.
* 실무에서 가장 많이 사용되는 방식.

---

## 5. 네이티브 SQL & JDBC 직접 사용

* JPQL로 표현 불가능한 특정 DB 고유 기능 사용 시 필요.
* JPA는 네이티브 SQL 지원.
* JDBC, MyBatis, SpringJdbcTemplate과 병행 가능.
* 단, 영속성 컨텍스트 flush 이후 사용해야 일관성 유지.

---

## 6. JPQL 문법 세부 사항

* 기본 SELECT:

  ```sql
  SELECT m FROM Member m WHERE m.age > 18
  ```
* UPDATE:

  ```sql
  UPDATE Member m SET m.age = 20 WHERE m.username = 'kim'
  ```
* DELETE:

  ```sql
  DELETE FROM Member m WHERE m.age < 18
  ```
* DISTINCT 지원.
* 프로젝션 대상: 엔티티, 임베디드 타입, 스칼라 타입.

---

## 7. 집합과 정렬

* 집합 함수:

    * `COUNT`, `SUM`, `AVG`, `MAX`, `MIN`
* 그룹핑:

    * `GROUP BY`, `HAVING`
* 정렬:

    * `ORDER BY`

---

## 8. 결과 조회 API

* `getResultList()`: 결과 리스트 반환 (0개 이상, 없으면 빈 리스트)
* `getSingleResult()`: 단일 객체 반환

    * 결과 없음: `NoResultException`
    * 결과 여러 개: `NonUniqueResultException`

---

## 9. 파라미터 바인딩

* 이름 기준 파라미터:

  ```java
  query.setParameter("username", "kim");
  ```
* 위치 기준 파라미터:

  ```java
  query.setParameter(1, "kim");
  ```
* 가독성과 유지보수를 위해 이름 기준 파라미터 권장.

---

## 10. 프로젝션

* 엔티티 프로젝션:

  ```sql
  SELECT m FROM Member m
  ```
* 임베디드 타입 프로젝션:

  ```sql
  SELECT m.address FROM Member m
  ```
* 스칼라 타입 프로젝션:

  ```sql
  SELECT m.username, m.age FROM Member m
  ```
* DTO 프로젝션:

  ```sql
  SELECT new jpabook.dto.UserDTO(m.username, m.age) FROM Member m
  ```

---

## 11. 페이징 API

* `setFirstResult(int startPosition)` : 조회 시작 위치 (0부터 시작)
* `setMaxResults(int maxResult)` : 조회 개수 제한

예시:

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m ORDER BY m.username", Member.class);
query.setFirstResult(0);
query.setMaxResults(10);
```

---

## 12. 조인과 서브쿼리

* 내부 조인:

  ```sql
  SELECT m FROM Member m JOIN m.team t
  ```
* 외부 조인:

  ```sql
  SELECT m FROM Member m LEFT JOIN m.team t
  ```
* 세타 조인:

  ```sql
  SELECT m, t FROM Member m, Team t WHERE m.username = t.name
  ```
* ON 절 (JPA 2.1+):

  ```sql
  SELECT m FROM Member m LEFT JOIN m.team t ON t.name = 'A'
  ```
* 서브쿼리:

    * `WHERE`, `HAVING` 절에서만 사용 가능.
    * `FROM` 절 서브쿼리는 불가.

---

## 13. 조건식과 함수

* CASE:

  ```sql
  SELECT CASE WHEN m.age <= 10 THEN '학생'
              WHEN m.age >= 60 THEN '노인'
              ELSE '일반' END
  FROM Member m
  ```
* COALESCE:

  ```sql
  SELECT COALESCE(m.username, '이름 없는 회원') FROM Member m
  ```
* NULLIF:

  ```sql
  SELECT NULLIF(m.username, '관리자') FROM Member m
  ```
* 기본 함수:

    * 문자열: `CONCAT`, `SUBSTRING`, `TRIM`, `LOWER`, `UPPER`, `LENGTH`, `LOCATE`
    * 수학: `ABS`, `SQRT`, `MOD`
    * 컬렉션: `SIZE`, `INDEX`
* 사용자 정의 함수도 방언에 등록 후 사용 가능.

---

## 14. 경로 표현식

* 상태 필드 경로: 탐색 끝 (예: `m.username`)
* 단일 값 연관 필드: 묵시적 내부 조인 발생 (예: `m.team`)
* 컬렉션 값 연관 필드: 탐색 불가, 명시적 조인 필요 (예: `m.orders`)
* ⚠️ 실무에서는 묵시적 조인 대신 **명시적 조인 권장** (쿼리 튜닝 용이).

---

## 15. 페치 조인

* SQL 한 번으로 연관 엔티티를 함께 조회.
* 문법:

  ```sql
  SELECT m FROM Member m JOIN FETCH m.team
  ```
* 특징:

    * 글로벌 로딩 전략보다 우선 적용.
    * 별칭 불가 (하이버네이트는 가능하지만 권장하지 않음).
    * 다수 컬렉션 페치 조인 불가.
    * 컬렉션 페치 조인 시 페이징 불가.

---

## 16. 다형성 쿼리

* 상속 구조에서 자식 타입만 조회 가능.
* `TYPE`:

  ```sql
  SELECT i FROM Item i WHERE TYPE(i) = Book
  ```
* `TREAT`:

  ```sql
  SELECT b FROM Item i TREAT(i AS Book) b
  ```

---

## 17. 엔티티 직접 사용

* JPQL에서 엔티티 직접 사용 가능 → SQL에서는 기본 키 값으로 변환.
* 예시:

  ```sql
  SELECT m FROM Member m WHERE m = :member
  SELECT m FROM Member m WHERE m.id = :memberId
  ```
* 외래 키 비교 가능 (`m.team = :team`).

---

## 18. Named 쿼리

* 미리 정의된 정적 쿼리.
* 정의 방법:

    * 어노테이션: `@NamedQuery`
    * XML 매핑 파일
* 특징:

    * 애플리케이션 로딩 시점에 파싱 및 검증.
    * 런타임 에러 줄이고 성능 최적화 가능.

---

## 19. 벌크 연산

* 한 번의 쿼리로 여러 로우 수정/삭제.
* 문법 예시:

  ```sql
  UPDATE Member m SET m.age = 20 WHERE m.username = 'kim'
  DELETE FROM Member m WHERE m.age < 18
  ```
* 실행: `executeUpdate()` → 영향받은 로우 수 반환.
* ⚠️ 주의: 벌크 연산은 영속성 컨텍스트 무시. 따라서 실행 후 컨텍스트 초기화 필요.
