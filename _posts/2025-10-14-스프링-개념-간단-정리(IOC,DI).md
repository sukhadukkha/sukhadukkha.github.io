---
layout: single
title: "스프링 IOC, DI 개념 간단 정리"
categories: [spring]
tags: [spring]
toc: true
author_profile: true
---
> IOC란?

-   IOC(Inversion Of Control)은 제어의 역전을 뜻하는 용어로, 프로그램 객체의 생성과 관리 권한이 스프링 컨테이너에게 넘어가는 개념을 말한다. 이는 개발자가 new로 직접 객체를 만들고 의존성을 연결하지 않고, 객체를 관리하지 않아도 스프링 컨테이너가 대신 객체를 생성하고 주입해준다. (DI)
-   컨테이너는 객체를 Bean으로 등록하고, 객체 간의 의존 관계를 설정하여 관리한다.
-   Bean은 @Component, @Service, @Controller, @Repository 등 어노테이션 기반으로 등록하거나, @Configuration 클래스 내에서 @Bean 메서드를 활용하여 등록할 수 있다.
---

> DI란?

-   DI(Dependency Injection)는 의존성 주입으로 객체 간의 관계를 외부에서 주입 받는 개념이다.
-   객체가 스스로 의존 대상을 만들지 않고, 스프링 컨테이너가 대신 주입해주는 방식이다.
-   예시 코드
    
```java
public class BookService {
    private BookRepository bookRepository = new BookRepository(); // 직접 생성
}
```

-   BookService에서 BookRepository 직접 생성 -> 강한 결합도
-   BookRepository가 변경된다면 BookService도 수정해야한다.

```java
@Service
@RequiredArgsConstructor
public class BookService {
    private final BookRepository bookRepository; // 스프링이 주입
}
```

-   BookRepository는 스프링 컨테이너에 @Repository 어노테이션을 통해 Bean으로 등록되어 있고, BookService는 단지 "필요하다"는 의존성만 선언함.
-   실제 주입은 스프링이 해줌 -> 낮은 결합, 테스트 용이, 유연한 구조
-   DI의 주입 방식 3가지

| 주입 방식 | 설명 / 예시 | 특징 | 권장 여부 |
| :--- | :--- | :--- | :--- |
| **생성자 주입** (Constructor Injection) | 객체를 생성할 때(생성자)를 통해 의존성 주입 | **불변성(Immutability) 유지**, 필수 의존성 명확, **테스트 용이** | ✅ **가장 권장** |
| **세터 주입** (Setter Injection) | Setter 메서드를 통해 의존성 주입 | 의존성을 **선택적**으로 주입할 때 유용, 객체 생성 후 나중에 의존성 **변경 가능** | ⚠️ 선택적 주입에 사용 |
| **필드 주입** (Field Injection) | `@Autowired`를 필드에 바로 붙여 주입 | 코드가 **가장 간단**함 | ❌ **비권장** |
| |

-   왜 DI가 중요할까?
    -   1\. 결합도 낮음 -> 코드 수정 없이 다른 구현체로 교체 가능 (BookRepository -> 다른 Repository로)
    -   2\. 테스트 용이 -> Mock 객체 주입으로 단위 테스트 쉬움
    -   3\. 유지보수성 향상 -> 구조적이고 유연한 코드
    -   4\. IOC 구현 기반 -> DI는 IOC 개념의 실제 구현 방식임
-   테스트가 용이하다는데 왜 용이한가? 예시로 알아보자
-   DI 없는 코드 (강한 결합도)
   
```java
public class BookService {
    private final BookRepository bookRepository = new BookRepository();

    public String findBookTitle(Long id) {
        return bookRepository.findById(id);
    }
}
```

-   이 코드의 문제점
    -   BookService가 BookRepository를 직접 new로 생성한다.
    -   BookService 내부에 Repository의 구현이 박혀있는 것이다.
    -   따라서 단위 테스트 시 "가짜 Repository"로 바꿔끼울 수가 없다.
-   테스트 불가능 예시

```java
@Test
void testFindBookTitle() {
    // BookService 내부에서 new BookRepository() 함 → Mock 주입 불가
    BookService service = new BookService();
    String title = service.findBookTitle(1L);
    // DB 연결 없는 환경에서는 테스트 불가능
}
```

-   DI 적용된 코드 (약한 결합)

```java
@Service
@RequiredArgsConstructor
public class BookService {
    private final BookRepository bookRepository; // 외부 주입
}
```

-   BookService에서 단지 "BookRepository"가 필요하다고 선언만 한 상태
-   스프링 컨테이너 또는 테스트 코드에서 그걸 대신 주입 할 수 있음
-   테스트 환경에서는 실제 DB대신 가짜(Mock)객체를 주입 할 수 있는 상태
-   테스트 예시 1. Mockito를 사용한 예시

```java
@ExtendWith(MockitoExtension.class)
class BookServiceTest {

    @Mock
    private BookRepository bookRepository; // 가짜 Repository

    @InjectMocks
    private BookService bookService; // Mock이 자동으로 주입됨

    @Test
    void findBookTitle_returnsExpectedValue() {
        // given
        when(bookRepository.findById(1L)).thenReturn("Effective Java");

        // when
        String title = bookService.findBookTitle(1L);

        // then
        assertEquals("Effective Java", title);
    }
}
```

-   @ExtendWith(MockitoExtension.class)는 "이 테스트 클래스 안에서 Mockito기능 (@Mock, @InjectMocks 등)을 활성화 하라"는 뜻
-   @Mock은 가짜 Mock객체를 생성 -> 즉 실제 DB 접근 없이 행동만 흉내내는 가짜 Repository를 만들어줌 -> 덕분에 DB 없이 테스트 가능
-   @InjectMocks는 테스트 대상 클래스 (BookService)를 만들고, 그 안의 의존성을위에서 만든 @Mock 객체로 자동 주입
-   즉, DI를 흉내내는 것 (new BookService(mockedBookRepository)

-   테스트 예시 2. 수동 주입(순수 자바 테스트)

```java
class FakeBookRepository implements BookRepository {
    @Override
    public String findById(Long id) {
        return "테스트용 가짜 데이터";
    }
}

@Test
void testFindBookTitleWithoutSpring() {
    BookRepository fakeRepo = new FakeBookRepository();
    BookService service = new BookService(fakeRepo); // 직접 주입
    assertEquals("테스트용 가짜 데이터", service.findBookTitle(1L));
}
```

-   스프링 없이 순수 자바 객체로 테스트 가능
-   DB 연결, 설정, 빈 등록 필요 없음

-   정리
    -   BookService.findBookTitle()은 내부적으로 bookRepository.findById()를 호출하기 때문에, Mock의 반환값을 지정해두면, DB 없이 그 동작 검증 가능