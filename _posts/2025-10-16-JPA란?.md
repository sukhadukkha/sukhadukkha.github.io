---
layout: single
title: "JPA란 무엇인가? 왜 탄생했나? 목적과 역할, 핵심 개념"
categories: [jpa]
tags: [jpa]
toc: true
author_profile: true
---

> 1\. JPA란 무엇인가?

-   JPA(Java Persistence API)는 자바에서 객체와 데이터베이스(Table)를 연결하기 위한 ORM(Object-Relational Mapping)이다.
-   즉 자바 객체와 RDB 데이터를 자동으로 매핑해주는 기술이다.

> 그럼 왜 탄생했나? 

-   과거 JDBC + SQL 을 직접 다루는 개발은 이런식으로 DB를 사용했다.

```java
Connection conn = DriverManager.getConnection(...);
PreparedStatement ps = conn.prepareStatement("SELECT * FROM member WHERE id = ?");
```

-   이 방식은 우선 이런 문제점들이 있었다.
    -   1\. SQL을 직접 써야해서 객체지향적이지 않다.
    -   2\. 테이블 구조 변경 시 코드 전체를 수정해야한다.
    -   3\. 비즈니스 로직보다 SQL 작성에 더 많은 시간을 소모해야한다.
    -   4\. 자바 객체 - SQL 테이블 과의 수동 매핑이 필요하다.
-   즉 , 객체지향언어와 관계형 DB의 방식이 너무나 달라 이 "패러다임 불일치"를 해결하기 위해 ORM 개념이 등장했고, 그걸 자바 진여에서 표준화 한 기술이 JPA다.
-   그럼 이 문제점들이 실제 코드에서는 어떻게 나타나는지 확인해보도록 하자

**1번 문제**

```java
// Member.java
class Member {
    Long id;
    String name;
}
```

```java
// JDBC 코드
Connection conn = DriverManager.getConnection(url, user, pass);
PreparedStatement ps = conn.prepareStatement(
        "INSERT INTO member (id, name) VALUES (?, ?)"
);
ps.setLong(1, member.getId());
        ps.setString(2, member.getName());
        ps.executeUpdate();
```

-   여기서 개발자는 객체 member를 다루고 싶지만, 직접 SQL을 써야하고, 필드 변경 시 매번 쿼리 문자열을 수정해야한다. 
-   이에 따라 객체지향 설계의 장점을 잃고, "데이터 중심 개발"이 되어버린다.

**2번 문제**

```sql
ALTER TABLE member ADD COLUMN email VARCHAR(100);
```

DB에서 컬럼을 하나 추가했다고 가정한다.

```
PreparedStatement ps = conn.prepareStatement(
        "INSERT INTO member (id, name, email) VALUES (?, ?, ?)"
);
```

-   그렇다면 위의 코드처럼 모든 sql에 email 컬럼을 수동으로 반영해줘야한다.
-   DB 스키마 변경 -> 전체 코드 수정이라는 비효율이 발생한다.
-   JPA는 이를 엔티티 클래스 하나만 수정하면 해결되게 만들어준다.

```java
@Entity
class Member {
    @Id
    Long id;
    String name;
    String email; // 필드 추가하면 자동으로 컬럼 반영
}
```

**3번 문제**

```java
public void join(Member member) throws SQLException {
    Connection conn = getConnection();
    PreparedStatement ps = conn.prepareStatement(
            "INSERT INTO member (id, name) VALUES (?, ?)"
    );
    ps.setLong(1, member.getId());
    ps.setString(2, member.getName());
    ps.executeUpdate();
    ps.close();
    conn.close();
}
```

-   여기서는 비즈니스 로직은 회원을 등록하는 Join 로직인데, 부가적인 SQL, Connection, 예외처리, 자원 해제가 전체 코드의 90%를 차지해버린다. JPA에서는 이걸 단 한 줄로 대체한다.
-   em.persist(member); // SQL 자동 생성 + 트랜잭션 관리

**4번 문제**

```java
PreparedStatement ps = conn.prepareStatement("SELECT * FROM member WHERE id = ?");
ResultSet rs = ps.executeQuery();
if (rs.next()) {
Member m = new Member();
    m.setId(rs.getLong("id"));
        m.setName(rs.getString("name"));
        }
```

-   조회를 할 때마다 ResultSet에서 일일이 값을 꺼내 객체에 넣어줘야한다. DB 컬럼 이름과 객체 필드 이름이 다르면 버그 발생 위험도 커진다.
-   반면 JPA는 자동 매핑을 제공하여 Member member = em.find(Member.class, id); 이 한줄로 SQL 실행 -> 결과 매핑 -> 객체 반환까지 처리된다.

---

> JPA의 목적

-   JPA의 목적은 다음과 같다.
    -   1\. 생산성 향상 -> SQL 작성 없이 객체로 CRUD 실행
    -   2\. 유지보수 용이 -> 테이블 구조 변경 시 코드 최소 수정
    -   3\. 객체 중심 개발 -> 객체지향 설계 그대로 DB 반영 가능
    -   4\. DB 종속성 최소화 -> DB 벤더(MySQL, Oracle 등) 교체 시 코드 수정 최소

> JPA의 역할

-   JPA는 직접 DB와 통신하지 않는다. JPA는 인터페이스이고, 그걸 구현한 라이브러리(Hibernate 등)가 실제로 SQL을 만들어 실행한다.
-   즉 구조는 다음과 같다
    -   JPA ← (표준) → Hibernate (구현체) → JDBC → DB
-   개발자는 JPA 인터페이스만 사용하고, Hibernamte가 내부적으로 SQL을 자동 생성해 실행한다.
-   즉 Member member = em.find(Member.class, 1L)이렇게 JPA를 사용하면, 내부에서는 이렇게 동작한다.
    -   1\. em.find()호출
    -   2\. 구현체 Hibernate가 동작
    -   3\. 내부적으로 JDBC Connection 획득
    -   4\. PreparedStatement 생성
    -   SQL문 자동 생성
    -   JDBCfh SQL 실행
    -   ResultSet 결과를 Member 객체로 자동 매핑
    -   Connection 반환
-   즉 JPA는 JDBC위에서 동작하는 상위 계층으로, 내부에서는 여전히 JDBC가 SQL을 실행하고 있다.

---

> JPA의 핵심 개념 정리

개념                                                                         설명

| **Entity** | DB 테이블에 매핑되는 자바 객체 (@Entity) |
| --- | --- |
| **EntityManager** | 엔티티 저장, 수정, 삭제, 조회 담당 (JPA의 핵심 인터페이스) |
| **Persistence Context** | 엔티티를 캐시(영속) 상태로 관리하는 공간 (1차 캐시, 변경 감지 등 제공) |
| **Transaction** | DB 작업 단위를 보장하기 위한 트랜잭션 관리 |
| **JPQL (Java Persistence Query Language)** | 엔티티 객체를 대상으로 하는 쿼리 언어 (SQL과 유사하지만 테이블이 아니라 객체 기준) |
| **ORM (Object Relational Mapping)** | 객체와 DB의 데이터를 자동으로 매핑하는 기술 개념 |
| **Dirty Checking (변경 감지)** | 엔티티 값이 바뀌면 JPA가 자동으로 UPDATE SQL 실행 |
| **Cascade / Fetch Type** | 연관된 엔티티 저장/삭제, 조회 시 전이(연쇄) 동작 제어 |

-   **JPA는 인터페이스고, 이를 구현하는 구현체가 존재한다. (Hibernate 등)**
    -   **이 구현체는 SQL을 생성하고 실행하며 내부적으로 JDBC를 통해 DB와 통신한다.**
-   이 정리를 통해, JPA가 어떻게 동작하는지, 왜 탄생했는지를 알 수 있었다. 