---
layout: single
title: "Docker란 무엇인가"
categories: [docker]
tags: [docker, TIL]
toc: true
author_profile: true
sidebar:
  nav: "docs"
---

# Docker란?

- Docker란 컨테이너 기술이다.
- 컨테이너를 생성하고 관리하는 도구이다.
- 정확히 무엇을 의미할까?

---

- 컨테이너는 표준화된 소프트웨어 유닛이다.
- 컨테이너는 기본적으로 코드 패키지이며, 해당 코드를 실행하는데 필요한 종속성과 도구가 포함되어있다.
- 이를 통해 사용자는 이를 사용하여 동일한 환경에서 작업을 해 나갈 수 있다.

# 왜 중요할까?

- 왜 독립적인 표준화된 패키지를 원할까?
- 예를들어 Node.js 버전이 각각의 로컬에서 다르다면 누구는 실행되고, 누구는 실행이 안돠는 문제가 발생할 수 있다.
---

# 왜 Docker인가?

- OS에 가상머신을 두고, 그 가상머신에 코드를 옮겨서 실행할 수 도 있다.
- 하지만 이는 문제가 발생한다
  - 오버헤드 문제(가상머신 별 동일하게 필요한 많은 파일들이 존재하고 머신이 많아질 수록 우리 컴퓨터의 하드웨어 자원은 줄어든다)
  - 성능 저하
  - 공유할 수 있는 단일 구성 파일이 없음

## 그럼 어떻게 Docker가 도와주나?

- 운영체제가 제공하는 내장 컨테이너를 사용한다.
- 그 위에 도커 엔진이라는 도구를 실행한다.
- 코드에 필요한 도구들은 포함되어있지만, 운영체제, 수많은 추가도구 같은 것들은 필요 없다.(VM보다 훨씬 적음)
- 구성 파일을 통해 컨테이너를 생성하고, 다른사람과 공유할 수 있다.
- 도커 이미지를 통해 환경 공유가 편해진다.
- 빠르다.
---

# 배운 명령어

- Dockerfile 만들고 빌드
- docker build -t <이름> .
  - 그냥 docker build 만 했을 경우에 docker images 명령어 입력했을 때 Image ID가 출력이 안되어서 run 못시키는 상황 발생했다
  - 발생했었지만, Images Id가 로그에 찍히는 것을 발견하고, docker build 로도 Image ID를 찾는데 성공했다.
- docker images
- docker run -p 3000:3000 <Image ID>
  - -p -> 포트 매핑 8080:80 
  - 80은 컨테이너 내부에서 애플리케이션이 리스닝 하는 포트
  - 8080은 외부에서 접속할 수 있도록 외부에 노출되는 포트
  - 8080 포트로 들어오는 모든 요청이 Docker 컨테이너의 80 포트로 전달된다.
  - -p가 없다면 외부에서의 컨테이너 내부의 서비스에 접근할 수 없다.
- docker ps -a (도커 모든 프로세스 출력)
- docker ps (현재 실행중인 도커 프로세스 출력)
- docker run -it <node> (node가 생성된 컨테이너 내부에서 실행중이고, -it를 통해 그 컨테이너에서 실행중인 노드와 상호작용 가능)
  - 이 명령어를 실행하면 현재 최신 노드 버전인 25버전으로 상호작용하지만, 내 local에는 22버전이 깔려있으므로 컨테이너를 사용하여 상호작용했다는 것이 증명된다.
- 터미널 하나 더 키고, docker stop <컨테이너 name>

---

# 이미지, 컨테이너 이게 무엇인가?

- 이미지는 컨테이너의 템플릿, 청사진이다.
- 이미지는 코드와 코드를 실행하는데 필요한 도구를 포함한다.
- 그런다음 컨테이너가 실행되어 코드를 실행한다.
- 이미지를 사용해서 여러개의 컨테이너를 만들 수 있다.
- **이미지는 모든 설정 명령과 모든 코드가 포함된 공유 가능한 패키지이다.**
- **컨테이너는 이미지의 구체적인 실행 인스턴스다.**
- **우리는 이미지를 기반으로 하는 컨테이너를 실행한다.**
- run 명령을 통해 이미지를 인스턴스화한다.
- 이것이 도커의 핵심 개념이다.

---
# Dockerfile ex

```dockerfile
FROM node           # 🌐 기반 이미지 설정: Docker Hub에서 'node'라는 이름의 공식 Node.js 이미지를 가져와 기본 환경으로 사용합니다. (여기서 컨테이너의 OS와 Node.js 런타임이 결정됩니다.)

WORKDIR /app        # 📂 작업 디렉토리 설정: 컨테이너 내부의 작업 공간을 /app 경로로 지정합니다. 이후의 명령어(COPY, RUN, CMD)는 모두 이 경로를 기준으로 실행됩니다.

COPY . /app         # 📋 파일 복사: Dockerfile이 있는 로컬 컴퓨터의 현재 디렉토리(.)에 있는 모든 파일과 폴더를 컨테이너 내부의 /app 디렉토리로 복사합니다.

RUN npm install     # ⚙️ 빌드 시 명령어 실행: 이미지를 만드는 단계에서 'npm install' 명령을 실행하여 package.json에 정의된 모든 Node.js 의존성 패키지를 설치합니다.

EXPOSE 80           # 🚪 노출 포트 문서화: 컨테이너 내부의 80번 포트가 외부로 노출될 것임을 선언(문서화)합니다. (실제 외부 포트 연결은 'docker run -p' 명령으로 지정해야 합니다.)

CMD ["node","server.js"] # ▶️ 컨테이너 실행 명령어: 컨테이너가 시작될 때 실행될 기본 명령을 배열 형태로 지정합니다. 컨테이너는 'node server.js' 명령을 실행하며 시작됩니다.
```

- docker run -p 3000:80 <Image id>
---

# 컨테이너를 실행할 이미지를 생성하고 가져오는법

- 존재하는 이미지 사용
   - 미리 구축된 공식 이미지, 동료가 만든 이미지, 커뮤니티에 존재하는 이미지
   - Docker hub

---
# 이미지와 컨테이너가 작동하는 방식

## 문제점 발생
  - 컨테이너를 다시 실행해도 코드의 수정사항이 반영되지 않는다.

- 여기서 **이미지가 작동하는 방식**을 이해해보자
- Dockerfile ex를 보면, 우리는 프로젝트 폴더 내의 모든 것을 /app 폴더에 복사하도록 지시힌다.
- 이는 복사한 시점에서의 소스코드의 스냅샷을 만든다.
- 이는 이미지를 재 빌드해야됨을 암시한다. (다른 방법 나중에 학습 예정)

## 이미지는 레이어 기반

- 이미지를 빌드하거나 재빌드 할 때 도커는 모든 명령 결과를 캐시하고, 이미지를 재 빌드할 때 변경된 사항이 없다면 캐시된 결과를 사용한다.
- 이것을 **레이어 기반 아키텍처**라고 한다.
- FROM node    
- WORKDIR /app 
- 이러한 모든 명령어를 기반으로 하는 이미지 레이어는 레이어를 저장하고, 캐시에 저장한다.
- 이는 COPY . /app 명령어를 통하여 프로젝트 루트폴더에서 코드 변경이 이뤄졌을 때, <br>레이어를 재생성 한다는 뜻이고 한 레이어가 변경되면 모든 후속 레이어도 다시 실행되므로 npm install도 다시 실행된다.
- npm install은 종속성 관리 파일인 package.json에서 무언가를 변경하지 않는 한, 다시 실행 할 필요가 없다.
- 이를통해 Dockerfile을 최적화 할 수 있다.

```dockerfile
FROM node

WORKDIR /app

COPY pacakge.json /app

RUN npm install

COPY . /app

EXPOSE 80

CMD ["node","server.js"]
```

- 이러한 최적화로 COPY 레이어가 변경되어도 상위 레이어인 npm install은 다시 실행되지 않는다.
- **이 최적화를 왜 했는지, 레이어 기반 아키텍처를 이해하는 것이 중요하다**

# 요약

- Dockerfile을 통해 코드를 이미지에 집어넣는다. 
- 그 코드를 실행하는데 필요한 도구인 실행 환경도 이미지에 집어넣는다.
- 도커는 궁극적으로 이미지가 아니라 컨테이너에 관한 것이다.
- 이미지 또한 중요한 개념이고, 이미지는 컨테이너의 청사진이다.
- 이미지를 인스턴스화 한게 컨테이너고, 이미지에 기반한 여러 컨테이너를 실행할 수 있다.
- 컨테이너는 이미지 위에 추가된 레이어다. 컨테이너는 이미지를 기반으로 하는 실행 애플리케이션이다.
- 실행되면 실행 중인 다른 컨테이너와는 독립적이다.
- 컨테이너가 이미지의 코드와 환경을 새 컨테이너로 복사하거나, 새 파일로 복사하지 않는다.
- 컨테이너는 이미지에 저장된 환경을 사용한다.