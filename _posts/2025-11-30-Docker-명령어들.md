---
layout: single
title: "Docker 명령어들"
categories: [docker]
tags: [docker]
toc: true
author_profile: true
---

## Docker 이미지 및 컨테이너 관리 명령어
---

##  1. 이미지 생성 및 확인

| 명령어 | 기능 |
| :--- | :--- |
| `docker build -t <name:tag> .` | 현재 디렉토리의 **Dockerfile을 사용하여 이미지 생성** 및 이름/태그 지정 |
| `docker images` | **태그가 있는** 모든 이미지 목록 출력 |
| `docker images -a` | `<none>:<none>` 이미지를 포함하여 **모든 이미지** 목록 출력 |
| `docker image inspect <Image ID>` | 특정 이미지에 대한 **상세 정보** 출력 |

---

##  2. 컨테이너 실행 및 중지 (`docker run`)

`docker run`은 이미지를 기반으로 **새 컨테이너를 생성하고 바로 실행**합니다.

| 명령어 | 기능 | 설명 |
| :--- | :--- | :--- |
| `docker run <Image ID>` | 기본 실행 (attached mode) | 터미널 사용 불가 (로그만 출력) |
| `docker run -d <Image ID>` | **Detached Mode**로 실행 | 백그라운드에서 실행 |
| `docker run -p 8000:80` | **포트 매핑** | 호스트 8000번 포트를 컨테이너 80번 포트에 연결 |
| `docker run -i` | **인터랙티브 모드** | 사용자 입력을 받을 수 있도록 허용 |
| `docker run -t` | **터미널(TTY) 생성** | 터미널을 할당하여 셸 환경 사용 가능 |
| `docker run --rm <Image ID>` | **자동 삭제** | 컨테이너 중지 시 자동으로 삭제 |
| `docker run --name happy <Image ID>` | **이름 지정** | 컨테이너에 `happy`라는 이름 지정 |

---

##  3. 컨테이너 상태 관리

중지된 컨테이너를 재실행하거나 실행 중인 컨테이너에 연결합니다.

| 명령어 | 기능 | 설명 |
| :--- | :--- | :--- |
| `docker ps` | **실행 중인** 모든 컨테이너 출력 | |
| `docker ps -a` | **모든 컨테이너** 출력 (실행 중 + 중지됨) | |
| `docker start <ID or name>` | **중지된 컨테이너 재실행** | detached mode가 기본값 |
| `docker start -a <ID or name>` | 중지된 컨테이너를 **attached mode**로 재실행 | |
| `docker stop <ID or name>` | **실행 중인 컨테이너 중지** | |
| `docker attach <ID or name>` | 실행 중인 컨테이너에 **다시 연결** (로그 및 입력 공유) | |

---

##  4. 로깅 및 파일 관리

| 명령어 | 기능 | 설명 |
| :--- | :--- | :--- |
| `docker logs <name>` | 컨테이너의 **과거 로그** 출력 | |
| `docker logs -f <name>` | 로그 출력 후 **새로운 로그 수신 대기** (Follow) | |
| `docker cp <원본 경로> <옮길 경로>` | 컨테이너와 로컬 환경 간에 **파일 복사** | 예: `docker cp logfile.txt my-container:/app/logs/` |

---

##  5. 이미지 및 컨테이너 삭제/정리

| 명령어 | 기능 | 설명 |
| :--- | :--- | :--- |
| `docker rm <name>` | **중지된 컨테이너 제거** | 실행 중인 컨테이너는 제거 불가 |
| `docker rmi <ID>` | **이미지 제거** | 해당 이미지를 사용하는 컨테이너를 먼저 삭제해야 함 |
| `docker container prune` | **정지 상태인 모든 컨테이너** 일괄 삭제 | |
| `docker image prune` | **사용하지 않는 이미지** 일괄 삭제 | `<none>:<none>` 태그 이미지 정리 |
| `docker image prune -a` | 컨테이너에서 **참조하지 않는 모든 이미지** 일괄 삭제 | |

---

##  6. 볼륨 관리

| 명령어 | 기능 |
| :--- | :--- | 
| `docker volume ls` | 시스템의 **볼륨 목록** 출력 
| `docker volume rm <vol_name>` | **특정 명명된/익명 볼륨** 삭제
| `docker volume prune` | **사용되지 않는 모든 볼륨** 일괄 삭제 (주로 익명 볼륨 정리, 연결이 끊긴 익명 볼륨)

---

## attached mode , detached mode

- attached mode는 터미널 사용 불가
- 출력 결과를 로그에서 보여줌(예: console.log)
- detached mode는 터미널 사용 가능
- 출력 결과를 로그에서 보여주지 않음
- **둘의 공통점은 컨테이너가 실행 중이라는 것**
- 컨테이너 내부의 정보가 필요한 경우 docker attach, or docker logs를 사용하여 추가 정보 확인 가능
- Docker는 꼭 웹 서버만 사용할 수 있는 것이 아니라, 간단한 유틸리티 컨테이너도 도커화 시켜서 상호작용 할 수 있다.

---

## name , tag

- name -> node 
- tag -> 12
- ex) FROM node:22

--- 
## 이미지 공유하는 방법

1. Dockerfile을 공유하기
2. 완성된 이미지를 공유하기

---
### Dockerfile vs. 완성된 이미지 공유 비교

| 특징 | Dockerfile 공유 (설계도) | 완성된 이미지 공유 (완제품) |
| :--- | :--- | :--- |
| **목적** | 개발 및 설정 **공유**, 유연성 확보 | 배포 및 **실행**, 일관성 확보 |
| **파일 형태** | 텍스트 파일 (\`Dockerfile\`) | 바이너리 파일 (모든 레이어 포함) |
| **주요 작업** | 수신자가 **\`docker build\`** 필요 | 수신자가 **\`docker pull\`** 후 즉시 \`run\` 가능 |
| **용량** | 매우 작음 | 큼 (수백 MB 이상) |
| **배포 속도** | 느림 (빌드 시간 소요) | **빠름** (빌드 과정 생략) |
| **환경 일관성** | 환경에 따라 빌드 결과가 달라질 수 있음 | 누가 받아도 **항상 동일한 환경** 보장 |
| **투명성/보안** | **높음** (내부 구조 확인 가능) | **낮음** (Black Box, 내부 확인 어려움) |
| **유연성** | **매우 높음** (쉽게 수정 가능) | 낮음 (수정 불가, 재빌드 필요) |

### 핵심 요약

* **Dockerfile**은 **소스 코드**와 같이 Git으로 관리하며 개발자 간의 **협업**에 적합합니다.
* **완성된 이미지**는 **실행 파일**과 같아서 서버나 QA 환경으로의 **배포**에 적합합니다.

--- 

## docker hub , push, pull

- docker hub를 통해 완성된 이미지를 공유
- **docker tag**는 이미지를 어디로 보낼지 목적지 주소를 지정함
- ex) docker tag node:latest sukhadukkha/node-hello-world
- 이렇게 tag를 통해 나의 docker hub repo로 docker push sukhadukkha/node-hello-world를 실행하면 push를 성공한다.
- docker push는 로컬에 저장된 이미지 목록을 확인하고 정확한 docker hub 위치로 전송을 실행한다.
- docker pull은 logout 되어있는 상태에서도 가능하며, docker pull <저장소 주소>로 Image를 가져올 수 있다.
- 이미지를 업데이트 하고 다시 Push 해놓았다면 docker run을 통해 이미지를 다시 실행했더라도 최신 버전의 이미지를 실행하지는 않는다.
- 그렇기에 최신 버전의 이미지를 사용하고 싶으면 docker pull로 최신 이미지를 가져오는 것이 중요하다.

