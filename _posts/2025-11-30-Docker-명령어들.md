---
layout: single
title: "Docker 명령어들"
categories: [docker]
tags: [docker, TIL]
toc: true
author_profile: true
---

# 이미지와 컨테이너 관리 명령어들

- docker build -t \<name:tag\> (이미지의 name과 tag를 지정하여 생성)
- docker ps (실행 중인 모든 컨테이너 출력)
- docker ps -a (중지된 컨테이너 포함한 과거에 있었던 모든 컨테이너 출력)
- docker run (이미지를 기반으로 한 새 컨테이너 만들고 시작, attached mode가 디폴트, 터미널 사용 불가)
  - docker run -p 8000:80 -d \<Image ID\> (detached 모드로 컨테이너 실행)
  - docker run -i (인터렉티브 모드로 사용, 입력 받을 수 있도록 허용)
  - docker run -t (터미널 생성해줌)
  - docker run -p 3000:80 -d(detached mode로 실행) **--rm** \<Image ID\> (컨테이너 중지될 때 실행한 컨테이너도 자동 삭제)
  - docker run -p 3000:80 -d --rm **--name** happy \<Image ID\> (컨테이너에 이름 happy로 지정)
  - docker run -p 3000:80 -d --rm --name happy \<Image name:tag\> (이미지 ID 대신 name과 tag로 연결)
- docker start <컨테이너 ID or name> (중지된 컨테이너 재실행, detached mode가 디폴트, 터미널 사용 가능)
  - docker start -a \<ID or name\> (중지된 컨테이너 attached 모드로 바로 실행)
  - docker start -i (사용자 입력 받도록 허용)
- docker stop \<ID or name\> (실행중인 컨테이너 중지)

- docker attach \<name or id\> (다시 컨테이너에 attached 모드로 연결)
- docker logs \<name\> (컨테이너의 과거 로그 출력)
  - docker logs -f \<name\> (컨테이너의 과거 로그 출력 및 수신 대기)
- docker rm \<name\> (컨테이너 제거, 컨테이너 실행중에는 제거 불가)
  - docker rmi \<ID\> (이미지 제거, 제거하려는 이미지 사용하고있는 컨테이너 부터 삭제 필요)
- docker images (이미지 출력, <none><none>아닌 것들만 출력됨)
  - docker images -a (모든 이미지 출력)
  - docker images inspect \<Image ID\> (이미지에 대한 정보 출력)
  - docker images 
- docker cp <원본 경로> <옮길 경로> (컨테이너에 추가된 파일 옮길 수 있음, ex : 변경하려는 웹서버의 설정 파일 컨테이너로, 컨테이너안에 있는 로그파일을 Local 환경으로 등)


## attached mode , detached mode

- attached mode는 터미널 사용 불가
- 출력 결과를 로그에서 보여줌(예: console.log)
- detached mode는 터미널 사용 가능
- 출력 결과를 로그에서 보여주지 않음
- **둘의 공통점은 컨테이너가 실행 중이라는 것**
- 컨테이너 내부의 정보가 필요한 경우 docker attach, or docker logs를 사용하여 추가 정보 확인 가능
- Docker는 꼭 웹 서버만 사용할 수 있는 것이 아니라, 간단한 유틸리티 컨테이너도 도커화 시켜서 상호작용 할 수 있다.

---

## name , tag

- name -> node 
- tag -> 12
- ex) FROM node:22

--- 
## 이미지 공유하는 방법

1. Dockerfile을 공유하기
2. 완성된 이미지를 공유하기

---
### Dockerfile vs. 완성된 이미지 공유 비교

| 특징 | Dockerfile 공유 (설계도) | 완성된 이미지 공유 (완제품) |
| :--- | :--- | :--- |
| **목적** | 개발 및 설정 **공유**, 유연성 확보 | 배포 및 **실행**, 일관성 확보 |
| **파일 형태** | 텍스트 파일 (\`Dockerfile\`) | 바이너리 파일 (모든 레이어 포함) |
| **주요 작업** | 수신자가 **\`docker build\`** 필요 | 수신자가 **\`docker pull\`** 후 즉시 \`run\` 가능 |
| **용량** | 매우 작음 | 큼 (수백 MB 이상) |
| **배포 속도** | 느림 (빌드 시간 소요) | **빠름** (빌드 과정 생략) |
| **환경 일관성** | 환경에 따라 빌드 결과가 달라질 수 있음 | 누가 받아도 **항상 동일한 환경** 보장 |
| **투명성/보안** | **높음** (내부 구조 확인 가능) | **낮음** (Black Box, 내부 확인 어려움) |
| **유연성** | **매우 높음** (쉽게 수정 가능) | 낮음 (수정 불가, 재빌드 필요) |

### 핵심 요약

* **Dockerfile**은 **소스 코드**와 같이 Git으로 관리하며 개발자 간의 **협업**에 적합합니다.
* **완성된 이미지**는 **실행 파일**과 같아서 서버나 QA 환경으로의 **배포**에 적합합니다.

--- 

## docker hub , push, pull

- docker hub를 통해 완성된 이미지를 공유
- **docker tag**는 이미지를 어디로 보낼지 목적지 주소를 지정함
- ex) docker tag node:latest sukhadukkha/node-hello-world
- 이렇게 tag를 통해 나의 docker hub repo로 docker push sukhadukkha/node-hello-world를 실행하면 push를 성공한다.
- docker push는 로컬에 저장된 이미지 목록을 확인하고 정확한 docker hub 위치로 전송을 실행한다.
- docker pull은 logout 되어있는 상태에서도 가능하며, docker pull <저장소 주소>로 Image를 가져올 수 있다.
- 이미지를 업데이트 하고 다시 Push 해놓았다면 docker run을 통해 이미지를 다시 실행했더라도 최신 버전의 이미지를 실행하지는 않는다.
- 그렇기에 최신 버전의 이미지를 사용하고 싶으면 docker pull로 최신 이미지를 가져오는 것이 중요하다.

