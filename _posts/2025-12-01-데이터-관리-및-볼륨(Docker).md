---
layout: single
title: "데이터 관리 및 볼륨"
categories: [docker]
tags: [docker]
toc: true
author_profile: true
---

## Data

1. 이미지에는 애플리케이션의 코드와 환경 데이터가 존재한다.
    - **이미지는 Read-only이기 때문에 빌드하면 코드는 Fixed된 상태로 변경 할 수가 없다.**
    - 무언가를 변경하고 적용하려면 새 이미지를 빌드해야 된다.
2. 임시 데이터도 존재한다.
    - 이는 애플리케이션이 실행되는 동안 생성된 데이터다.
    - ex) 서버의 입력폼에 사용자가 입력한 데이터
    - 메모리에 저장되거나 DB에 저장될 수도 있다.
    - **하지만 컨테이너가 종료될 때 잃어도 상관이 없는 데이터다.**
    - Read + write 데이터이기 때문에, 이미지가 아닌 컨테이너에 저장된다.
    - 이미지 Layer위의 **Container Layer는 Read-write 권한을 가진다.**
    - 이 데이터는 우리의 Local File에도, Local machine에도, 이미지에도 존재하지 않으며 Container 안에 존재한다.
3. 영구 애플리케이션 데이터도 존재한다.
    - ex) 사용자의 정보를 받아서 DB에 저장하는 데이터 ID, PW..
    - 컨테이너가 중지되더라도 잃어버리면 안되는 데이터다.
    - Read-write 데이터이고, **볼륨의 도움을 받아 저장된다.**
---

## Container 내부의 데이터

- Image를 빌드하면 로컬 디렉터리의 구조가 그대로 컨테이너 안으로 들어간다.
- 만약 컨테이너를 실행하고, 애플리케이션 안에서 데이터를 저장했다면 그 데이터는 우리 로컬에 저장되는 것이 아니라, 그 컨테이너 내부에 저장이 되는것이다.
- 가령 Form을 이용해 txt 파일을 특정 디렉터리에 저장하는 애플리케이션이라고 할 때, 컨테이너 내에서 저장을 한다면 그 데이터는 로컬에 보이지 않고, 컨테이너 내부에 존재하게 된다.
- 이는 휘발성 데이터다.

### 문제점 발생

- docker run --rm 옵션을 주고 컨테이너를 실행한다.
- 컨테이너를 중지하고 다시 컨테이너를 실행해본다.
- 작성하고 저장했던 파일이 컨테이너 내에서 사라져있다.
- docker run --rm 옵션을 주지 않고 실행해본다.
- docker stop을 하고, 다시 docker start로 제거되지 않은 컨테이너를 다시 실행해본다.
- 작성하고 저장했던 파일이 컨테이너 내에 여전히 존재한다.
- 여기서 문제는 파일 시스템이 컨테이너 내부에 존재한다는 것이다.
- 컨테이너를 중지했다고 해도, 파일 시스템이 제거되거나 초기화 되지 않는다.
- **하지만 컨테이너를 제거한다면? 컨테이너의 모든 데이터가 지워진다. 동일한 이미지에 기반해서 컨테이너를 재시작해도 그 데이터는 남아있지 않다.**
- `이는 동일한 이미지에 기반한 컨테이너들이 여러개 있다면 그것들은 완전히 격리된 상태라는 것이다.`
- 이미지는 Read-only이고, 그 데이터는 Read-write 권한이 있는 Container 안에 저장이 되는 것이다. 이미지에 저장되는 것이 아니다.
- `컨테이너가 제거되더라도 데이터가 남아있는 것을 원한다면 어떻게 해야할까?`

---

## Volumes 

- **볼륨은 데이터를 유지하도록 하는 기능**
- `볼륨은 Host Machine의 폴더이다.` **컨테이너나 이미지에 있는 것이 아니다.**
- 볼륨은 도커 컨테이너 내부의 폴더에 매핑된다.
- 컨테이너 내부의 폴더를 컨테이너 외부 폴더에 연결할 수 있다. 그리고 두 폴더의 변경 사항은 다른 폴더에 반영된다!
- 즉 호스트 머신에 파일을 추가하면 컨테이너 내부에서도 액세스 할 수 있고, 컨테이너가 매핑된 경로에 파일을 추가하면 호스트 머신에서도 사용할 수 있는 것이다!
- 볼륨은 컨테이너가 종료되더라도 계속 존재한다. 컨테이너는 볼륨에 데이터를 읽고 쓸 수 있다.

### Volumes 사용법 (Anonymous Volumes, Named Volumes)

- Volumes의 종류는 Anonymous Volumes, Named Volumes 2가지가 있다.
- 두 경우 모두 도커는 일부 폴더와 경로를 호스트 머신에 설정한다.
- docker volume ls (volumes 출력)
- `Anonymous Volumes은** 컨테이너가 존재하는 동안에만 실제로 존재한다. (컨테이너 중지하면 사라짐)`
  - 컨테이너에 정의된 경로는 생성된 어떠한 볼륨에 매핑된다.
  - 컨테이너의 /app/feedback 경로는 호스트 머신의 어떤 폴더에 매핑된다. 우리는 그 경로를 모른다. 도커가 관리한다. 사용자가 액세스 할 수 없다.
  - Dockerfile의 Volume Layer로 사용 혹은 -v /app/feedback
- `Named Volumes은 컨테이너가 제거되어도 유지된다. 하드 드라이브의 폴더가 그대로 유지된다.`
  - 이는 편집하거나 직접 확인 할 필요가 없는 중요한 데이터를 저장하는데 적합하다.
  - 실질적으로 도커가 관리하는 숨겨진 이 폴더에 접근하지 않을 것이기 때문이다.
  - 컨테이너를 실행할 때 명명된 볼륨 생성으로 사용
  - docker run -d --name feedback-app -p 3000:80 --rm `-v feedback:/app/feedback` feedback-node:volumes
  - feedback (볼륨 이름)
  - : (호스트 측 위치와 컨테이너 내부 위치 구분하는 역할)
  - /app/feedback (컨테이너 파일 시스템 내의 경로, 이 경로랑 Named Volumes인 feedback과 연결)
  - **feedback 볼륨은 호스트 내부의 어딘가에 저장되고, 도커가 관리한다. 확인해보려면 docker volume ls를 해보자**
  - 컨테이너가 제거되더라도 feedback 볼륨은 제거되지 않는다.
  - **이를 통해 Named Volumes에 저장된 데이터를 컨테이너 간 공유할 수 있다.** 


Anonymous Volumes 
```dockerfile
FROM node

WORKDIR /app

COPY package.json /app

RUN npm install

COPY . /app

EXPOSE 80

VOLUME [ "/app/feedback" ]

CMD [ "node","server.js" ]
```

---
## Bind Mounts

- **소스코드를 변경한다면 이미지를 다시 빌드하지 않는 한 변경사항은 실행중인 컨테이너에 반영되지 않는다.**
- 항상 이미지를 다시 빌드하는 것은 번거롭다.
- 이것을 바인드 마운트가 도와준다.
- **바인드 마운트는 볼륨과 다르게 저장소가 호스트 머신의 어디에 있는지 알 수 있다.**
- **호스트 머신 상에 매핑 될 컨테이너의 경로를 설정한다.**
- 컨테이너는 소스코드를 스냅샷에서 복사하는 것이 아닌, 바인딩 마운트에서 복사하기 때문에 변경사항이 있더라도 컨테이너는 항상 최신 코드에 액세스 할 수 있다.
- **영구적이고 편집 가능한 데이터에 적합하다.**

### 문제점 발생
- `docker run -d --name feedback-app -p 3000:80 --rm -v feedback:/app/feedback -v "/Users/jihopark/DevOpsStudy/Docker/data-volumes-01-starting-setup:/app" feedback-node:volumes`
- 또한 도커에서 내가 지정한 폴더에 액세스 할 수 있는 권한을 주어야 하는데 그 설정은 DockerDesktop -> settings -> Virtual file shares 특정 폴더에 대한 권한을 추가할 수 있다.
- 하지만 저 명령으로는 애플리케이션이 실행조차 안된다. 
- **docker logs feedback-app**을 통해 log를 확인해보면 `Cannot find module 'express'`라는 에러가 발생항 것을 확인할 수 있다.
- 문제점은 무엇이었을까?
- 로컬 폴더에는 앱에 필요한 모든 종속성이 있는 node_modules 폴더가 존재하지 않았다. 이는 이미지에서 RUN npm install을 통해 컨테이너 안에서 존재하는 것이다. 
- **지정한 마운트를 컨테이너에 바인딩한다면 /app폴더의 모든 것을 로컬의 환경으로 덮어씌우기 때문에 Dockerfile에서 정의된 부분이 무의미하게된다.**
- 그럼 어떻게 해결할까?
- 참고 : 전체 경로를 복사하여 넣고싶지 않다면 
- macOs/Linux -v $(pwd):/app 
- Windows: -v "%cd%":/app 를 통해 현재 작업중인 폴더 마운트가 가능하다.

### 문제점 해결

- 도커에게 외부에서 덮어쓰지 말아야 하는 부분이 있다는걸 알려주어야 한다.
- 이는 다른 Anonymous 볼륨을 추가하는 것을 통해 해결 할 수 있다.
- docker run -d --name feedback-app -p 3000:80 --rm -v feedback:/app/feedback -v "/Users/jihopark/DevOpsStudy/Docker/data-volumes-01-starting-setup:/app" **-v /app/node_modules** feedback-node:volumes
  - 참고 - **: 앞에 로컬 경로가 붙으면 바인드 마운트, : 앞에 경로가 아닌 것이 붙으면 Named Volumes, 아무것도 안붙으면 Anonymous Volumes**
- `도커는 더 구체적인 경로에서 바인딩하기 때문에, /app이 아닌 /app/node_modules 폴더에 바인딩 한다.`
- 도커는 /app/node_modules에 있는 기존 파일들을 익명 볼륨으로 복사하고, 컨테이너 내부의 이 경론는 마스킹 되어 덮어씌워지지 않는다.
- 이렇게 생성된 익명 볼륨은 호스트 머신 어딘가에 저장되고, 컨테이너가 삭제되면 사라진다.
