---
layout: single
title: "네트워킹: 컨테이너의 통신"
categories: [docker]
tags: [docker]
toc: true
author_profile: true
---


# Network & reqest

- 컨테이너 내부에서 외부 웹사이트로의 HTTP request or 웹 API 요청을 보낼 수 있다.
- 호스트 머신에서 실행되는 서비스와의 통신이 필요할 때도 있다. (웹서비스, DB)
- 컨테이너 TO WWW, 컨테이너 TO 호스트 머신, 컨테이너 TO 다른 컨테이너
- **각각의 컨테이너에서는 하나의 작업만 하는것이 강력히 권장됨**

```javascript
const express = require('express');
const bodyParser = require('body-parser');
const axios = require('axios').default;
const mongoose = require('mongoose');

const Favorite = require('./models/favorite');

const app = express();

app.use(bodyParser.json());

app.get('/favorites', async (req, res) => {
    const favorites = await Favorite.find();
    res.status(200).json({
    favorites: favorites,
});
});

app.post('/favorites', async (req, res) => {
    const favName = req.body.name;
    const favType = req.body.type;
    const favUrl = req.body.url;

    try {
        if (favType !== 'movie' && favType !== 'character') {
            throw new Error('"type" should be "movie" or "character"!');
        }
        const existingFav = await Favorite.findOne({ name: favName });
        if (existingFav) {
            throw new Error('Favorite exists already!');
        }
    } catch (error) {
        return res.status(500).json({ message: error.message });
    }

    const favorite = new Favorite({
    name: favName,
    type: favType,
    url: favUrl,
});

    try {
        await favorite.save();
        res
            .status(201)
            .json({ message: 'Favorite saved!', favorite: favorite.toObject() });
    } catch (error) {
        res.status(500).json({ message: 'Something went wrong.' });
    }
});

app.get('/movies', async (req, res) => {
    try {
        const response = await axios.get('https://swapi.dev/api/films');
        res.status(200).json({ movies: response.data });
    } catch (error) {
        res.status(500).json({ message: 'Something went wrong.' });
    }
});

app.get('/people', async (req, res) => {
    try {
        const response = await axios.get('https://swapi.dev/api/people');
        res.status(200).json({ people: response.data });
    } catch (error) {
        res.status(500).json({ message: 'Something went wrong.' });
    }
});

mongoose.connect(
'mongodb://localhost:27017/swfavorites',
{ useNewUrlParser: true },
(err) => {
        if (err) {
            console.log(err);
        } else {
            app.listen(3000);
        }
    }
);
```

```dockerfile
FROM node

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

CMD ["node", "app.js"]
```

- Local에는 MongoDB가 안깔려있어 실행 및 통신이 불가능하지만 컨테이너에 넣는다면 가능하다!
- **MongoDB의 설치는 이 컨테이너의 일부가 아니다!**
- 이대로 실행하면 MongoNetworkError가 발생한다.
- **MongoDB부분을 주석처리 하면, 컨테이너에서 WWW로 가는 요청은 특별한 설정 없이 잘 작동하는 것을 확인할 수 있다.**
```javascript
const express = require('express');
const bodyParser = require('body-parser');
const axios = require('axios').default;
const mongoose = require('mongoose');

const Favorite = require('./models/favorite');

const app = express();

app.use(bodyParser.json());

app.get('/favorites', async (req, res) => {
  const favorites = await Favorite.find();
  res.status(200).json({
    favorites: favorites,
  });
});

app.post('/favorites', async (req, res) => {
  const favName = req.body.name;
  const favType = req.body.type;
  const favUrl = req.body.url;

  try {
    if (favType !== 'movie' && favType !== 'character') {
      throw new Error('"type" should be "movie" or "character"!');
    }
    const existingFav = await Favorite.findOne({ name: favName });
    if (existingFav) {
      throw new Error('Favorite exists already!');
    }
  } catch (error) {
    return res.status(500).json({ message: error.message });
  }

  const favorite = new Favorite({
    name: favName,
    type: favType,
    url: favUrl,
  });

  try {
    await favorite.save();
    res
      .status(201)
      .json({ message: 'Favorite saved!', favorite: favorite.toObject() });
  } catch (error) {
    res.status(500).json({ message: 'Something went wrong.' });
  }
});

app.get('/movies', async (req, res) => {
  try {
    const response = await axios.get('https://swapi.dev/api/films');
    res.status(200).json({ movies: response.data });
  } catch (error) {
    res.status(500).json({ message: 'Something went wrong.' });
  }
});

app.get('/people', async (req, res) => {
  try {
    const response = await axios.get('https://swapi.dev/api/people');
    res.status(200).json({ people: response.data });
  } catch (error) {
    res.status(500).json({ message: 'Something went wrong.' });
  }
});
app.listen(3000);

// mongoose.connect(
//   'mongodb://localhost:27017/swfavorites',
//   { useNewUrlParser: true },
//   (err) => {
//     if (err) {
//       console.log(err);
//     } else {
//       app.listen(3000);
//     }
//   }
//);

```

-  'mongodb://**host.docker.internal**:27017/swfavorites'로 주소를 변경하면 docker가 호스트 머신 내부의 MongoDB를 사용할 수 있다.

---

## 컨테이너 TO 컨테이너

- 컨테이너를 2개로 나눠 한개는 Node, 한개는 MongoDB용으로 분리한다.
- `docker run -d --name mongodb mongo` 
  - **Docker Hub에 이미 존재하는 MongoDB 이미지로 컨테이너를 실행**
  - docker container inspect mongodb -> IP 주소 확인
  - `'mongodb://172.17.0.2:27017/swfavorites'`
  - 27017 -> MongoDB 디폴트 포트
- **문제점 발생!**
  - 컨테이너를 사용하기 위해 IP주소를 확인하고 바꿔주고 다시 Build하는게 번거롭다. 또한 IP주소가 바뀌면 다시 주소를 바꾸고 이미지를 새로 build해야한다.

---
## 더 쉬운 통신 (docker network create)

- docker run --network my_network   
  - 도커 컨테이너들을 같은 my_network 안으로 넣을 수 있다.
  - **이를 통해 같은 네트워크의 컨테이너들은 자동으로 IP를 조회하고 통신한다.**
- `docker run -d --name mongodb --network favorites-net mongo`
  - 이는 에러 발생
  - 이유는 ? **volumes과 달리 도커는 자동으로 네트워크를 생성하지 않는다.**
  - **docker network crate favorites-net** 로 네트워크 생성
  - docker network ls 로 네트워크 목록 출력 가능
  - 그 후 다시 `docker run -d --name mongodb --network favorites-net mongo` 성공!
    - 참고: 왜 -p가 없나? -p태그는 컨테이너의 무언가에 연결 할 계획일 때만 필요한데, 지금은 그저 DB를 사용하는 것이니 필요 없음. 또한 컨테이너간의 network로 연결이 있다면 포트를 게시할 필요가 없다.
  - mongodb://mongodb:27017/swfavorites
  - 이미지 재 빌드후 컨테이너 실행 docker run -d --name favorites--rm **--network favorites-net** -p 3000:3000 favorites-node

### Docker Networks Driver

- Default는 bridge Driver (컨테이너가 동일한 네트워크에 있으면 이름으로 서로를 찾을 수 있음)
- 대부분 bridge Driver 사용
- 다른 driver들은 필요한 경우 찾아보자 
