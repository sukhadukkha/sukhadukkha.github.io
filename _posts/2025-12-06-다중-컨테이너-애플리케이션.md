---
layout: single
title: "다중 컨테이너 애플리케이션 구축 (문제점 다수 발생 및 해결 정리)"
categories: [docker]
tags: [docker]
toc: true
author_profile: true
---


# 다중 컨테이너 애플리케이션

- 애플리케이션은 단일 컨테이너로도 동작할 수 있지만, 여러 서비스로 구성된 애플리케이션도 존재한다. (백엔드 서버, 프론트엔드, DB ...)

## 예제 애플리케이션 구조
- DB (MongoDB)
- Backend (NodeJS)
- Frontend (React)
---

## 다중 컨테이너 구축 과정 (하나의 네트워크에 구축해보기)

- **네트워크 생성**
  - docker network create goals-net
  - **같은 네트워크 안에서 실행된다면 포트 게시 필요 없음**

```
.dockerignore 파일 

node_modules  # COPY . . 할 때, Local에 있는 node_modules는 컨테이너에 복사하지 말라는 명령
.git          
Dockerfile
```

- `MongoDB 컨테이너 실행`
  - docker run --name mongodb --rm -d --network goals-net mongo 
    - 이렇게 실행하고 컨테이너를 종료하면 컨테이너가 제거되면서 그 안에 있던 데이터도 날아간다!
    - 어떻게 해결? -> 데이터가 컨테이너 제거 뒤에도 살아남도록 하드디스크 어딘가에 저장 필요
    - **Named Volumes 사용**, Docker Hub의 MongoDB 문서 참조하면 컨테이너 내부에 DB파일을 저장하는 곳은 `/data/db`라는 것 확인 가능 
    - docker run --name mongodb -v data:/data/db --rm -d --network goals-net mongo
    - **도커는 data라는 볼륨이 존재하지 않으면 만들고, 호스트 머신 상의 알 수 없는 경로에 만든다. 그 후 컨테이너의 데이터를 저장한다!**
    - **이미 data라는 볼륨이 존재한다면, 도커는 호스트 머신의 폴더에 이미 있는 데이터를 컨테이너의 /data/db폴더에 로드한다!**
  - `보안과 데이터베이스 액세스 방지`
    - Docker Hub의 MongoDB 문서 참조하면 환경변수 확인 가능
    - docker run --name mongodb -d --rm --network goals-net -v data:/data/db **-e MONGO_INITDB_ROOT_USERNAME=max -e MONGO_INITDB_ROOT_PASSWORD=secret** mongo
    - backend에서 경로를 재 설정 mongodb://max:secret@mongodb:27017/course-goals?authSource=admin 및 이미지 재 빌드

---
- `backend Dockerfile` 
```dockerfile
FROM node

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

ARG DEFAULT_PORT=80

ENV PORT $DEFAULT_PORT

EXPOSE $PORT

ENV MONGODB_USERNAME=root

ENV MONGODB_PASSWORD=secret

CMD ["npm", "start"]
```

- `backend 컨테이너 실행`
  - backend MongoDB 접근 경로 설정
  - mongodb://mongodb:27017/course-goals (경로의 mongodb는 컨테이너 이름과 동일해야함)
  - 이미지 재 빌드
  - **리액트와 통신하기 위해서는 컨테이너의 포트 80을 로컬 호스트 머신의 포트 80에 게시 필요, MongoDB와 통신하기 위해서는 네트워크 명시 필요**
    - 왜 80포트 ? **기본적으로 HTTP 프로토콜은 포트 번호 명시하지 않으면 자동으로 80포트 사용하기 때문이다!**
    - docker run --name goals-backend --rm -d --network goals-net -p 80:80 goals-node
  - 컨테이너에서도 소스코드 변경사항 바로 반영하기 + log파일 유지하기
    - docker run --name goals-backend -d --rm --network goals-net -p 80:80 -v /app/node_modules -v logs:/app/logs -v /Users/jihopark/DevOpsStudy/Docker/multi-01-starting-setup/backend:/app goals-backend:latest
    - nodemon 사용
  
- 접근 경로를 하드코딩하기 싫다면? 
  - 환경변수 사용
  - 백틱 필요(javaScript 문법) `mongodb://${process.env.MONGODB_USERNAME}:${process.env.MONGODB_PASSWORD}@mongodb:27017/course-goals?authSource=admin`
  

--- 

- `frontend Docker file`

```dockerfile

FROM node:14 # node가 코드에 쓰여서가 아닌, 프로젝트 설정에 NodeJS가 필요하기 때문

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm","start"]


```

- `frontend 컨테이너 실행`
  - localhost로 접근한 모든 곳은 백엔드 컨테이너의 이름이 되어야 함
  - http://localhost/goals -> http://goals-backend/goals
    - 이는 에러 발생하는데 이유는 문제점에서 정리함
  - 문제점 해결 후 (다시 localhost로)
  - 이미지 재 빌드
  - docker run --name goals-frontend --network goals-net --rm -p 3000:3000 -it goals-react
  - 3000번 포트 열어놓는 이유는 브라우저에서 localhost 3000번 포트로 접속 요청 하여 통신할것이기 때문 -> 3000번 포트로 요청하면 컨테이너 내부의 3000번 포트로 요청 전달 
    - 리액트는 네트워크가 필요 없으니 제거
  - docker run --name goals-frontend --rm -p 3000:3000 -it goals-react
- 실시간 소스코드 컨테이너에 업데이트
  - 바인드 마운트 사용
  - docker run -v :/app/src --name goals-frontend --rm -p 3000:3000 -it goals-react
  - /app/src에 로컬 호스트 머신의 src 폴더를 바인딩

---

### 발생했던 문제점

- 첫 번째: frontend 컨테이너를 실행했을 때, localhost:3000을 접속해도 접속되지않고, 컨테이너가 바로 중지되는 문제 발생
  - 원인은?
    - React 프로젝트 설정에 관한 문제, -it 태그 추가하여 상호작용 하기를 원한다고 알려야함. 안그러면 중지되는 로직이 들어있는 듯
  - 해결은?
    - `docker run --name goals-frontend --rm -p 3000:3000 -it -goals-react`
- 두 번째: 최신 버전 node와 OpenSSL 3.0 호환성 문제
  - 원인은?
    - `docker run --name goals-frontend --rm -p 3000:3000 -it -goals-react` 실행하면
    - 에러발생 Error: error:0308010C:digital envelope routines::unsupported
  - 해결은?
    - FROM node로 최신 25버전을 사용하는 것이 아닌 태그 지정 FROM node:14, 이미지 재 빌드
- 세 번째 : 프론트엔드 컨테이너를 실행하자 `Failed to load resource: net::ERR_NAME_NOT_RESOLVED` 에러 발생
  - 원인은? 
    - **리액트는 자바 스크립트기반이고, 리액트는 도커 컨테이너 안에서 실행되는 javaScript가 아닌 브라우저에서 실행되는 javaScript를 가지고 있다.** 즉 이는 http://goals-backend/goals 여기에서의 백엔드 컨테이너에 브라우저에서 접근을 할 수 없게 되는 것이다.
  - 해결은?
    - 백엔드 컨테이너의 80포트를 열고(-p 80:80) , localhost로 요청 보내기
- 네 번째 : MongoDB의 보안 환경변수를 설정하고 백엔드 서버를 다시 실행했다. 하지만 자꾸 인증 실패 에러가 발생했다.
  - 원인은? 
    - 원래 있었던 볼륨인 data 때문에 mongoDB가 계속 존재했었고, 환경변수를 지정하고 다시 실행해도 원래 있었던 환경 변수를 지정하고 실행하지 않았던 볼륨에는 인증이 실패했었던 것이다.
  - 해결은?
    - docker volume ls로 data 볼륨이 있는 것을 확인하고, docker volume rm data로 볼륨을 지우고 다시
    - docker run --name mongodb -d --rm --network goals-net -v data:/data/db -e ~~ 이렇게 다시 환경변수를 지정해주고 실행하니 해결되었다!
- 다섯 번째 : PORT를 환경변수로 지정해놓고 80번 포트를 안열어놨더니 리액트에서 서버에 접근하지 못하는 문제 발생
  - 원인은?
    - 환경변수를 지정해놔도 이는 컨테이너 내부의 80번 포트를 열어놓는 것이지, 외부에서 들어오는 요청을 열어놓은 것이 아니다.
  - 해결은? 
    - 프론트엔드와 통신하려면 -p 80:80 태그 필수!
    - 호스트의 80번 포트로 들어오는 모든 트래픽을 도커 컨테이너 내부의 80번 포트로 전달하라

--- 
## 다음 최적화

- 문제점
  - docker run 명령이 너무나도 길다. 
  - 너무나도 길면서 기억 할 것도 많다. (환경변수, 볼륨 ...)
  - 틀린 명령을 실행하기가 쉽다!
  - 지금은 개발용으로만 컨테이너가 실행되고, production용(실제 배포 제품)으로는 실행하지 못했다.
- 해결은? 
  - 명령을 저장하고 개별적으로 실행하지 않아도 되면 좋겠다.
  - 하나의 명령을 통해 모든 컨테이너에 필요한 command가 한 번에 생성되면 좋겠다.
