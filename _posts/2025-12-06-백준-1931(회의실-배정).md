---
layout: single
title: "백준 1931: 회의실 배정"
categories: [Baekjoon]
tags: [Algorithm]
toc: true
author_profile: true
---

# 문제

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.


# 입력

첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.


## 접근 방법

- 하나의 객체가 하나의 활동에 대해서만 작업할 수 있을 때, 최대 활동의 수 선택하는 문제
- 하나의 회의 끝나기 전에 다른 활동 선택할 수 없다.
- 회의의 최대 개수? -> 그리디?

## 배운점

- Comparator의 compare 메서드의 정렬 방식에 대한 규칙 다시 상기
  - 음수 : A가 B보다 작다는 뜻 A가 B 앞에 위치
  - 양수 : A가 B보다 크다는 뜻 A가 B 뒤에 위치

--- 
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        int[][] time = new int[N][2];

        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());

            time[i][0] = Integer.parseInt(st.nextToken());
            time[i][1] = Integer.parseInt(st.nextToken());
        }

        // [1,4] , [0,6] -> 1 != 0 -> 4 - 6 -> -2 -> 음수이니 종료 시간이 빠른 순서대로 정렬
        Arrays.sort(time, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                // 종료시간이 같다면?
                if (o1[1] == o2[1]) {
                    // 시작 시간이 빠른 순서대로 정렬
                    return o1[0] - o2[0];
                }
                // 종료 시간이 다르다면?
                // 종료 시간이 빠른 순서대로 정렬
                return o1[1] - o2[1];
            }
        });

        int count = 0;
        int prev_end_time = 0; // 이전 회의가 끝난 시간
        for (int i = 0; i < N; i++) {

            // 이전 종료 시간이 현재 시작 시간보다 빠르다면
            // 0 <= 1
            // 이전 회의 종료 시간 = 4
            // count ++
            if (prev_end_time <= time[i][0]) {
                // 이전 종료 시간을 현재 종료 시간으로
                prev_end_time = time[i][1];
                count++;
            }
        }

        System.out.println(count);
    }
}
```

---