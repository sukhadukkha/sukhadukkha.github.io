---
layout: single
title:  "다중 컨테이너 애플리케이션 구축 : (2) Docker-Compose"
categories: [docker]
tags: [docker]
toc: true
author_profile: true
---


## 문제점 : 너무나도 긴 명령들 + 많은 해야 할 일

- 해야 할 일이 너무 많다!
- 더 많은 컨테이너로 구성되어있다면 빌드하기가 너무 어려울 것이다.
- 해결은? 
  - **Docker-Compose**

```
docker network create goals-net

docker run --name mongodb \
    -e MONGO_INITDB_ROOT_USERNAME=max \
    -e MONGO_INITDB_ROOT_PASSWORD=secret \
    -v data:/data/db \
    --rm \
    -d \
    --network goals-net \
    mongo


docker build -t goals-node .

docker run --name goals-backend \
    -e MONGODB_USERNAME=max \
    -e MONGODB_PASSWORD=secret \
    -v logs:/app/logs \
    -v /Users/jihopark/Udemy/DockerStudy/Docker/multi-01-starting-setup/backend:/app \
    -v /app/node_modules \
    --rm \
    -d \
    --network goals-net \
    -p 80:80 \
    goals-node



docker build -t goals-react .

docker run --name goals-frontend \
    -v /Users/jihopark/Udemy/DockerStudy/Docker/multi-01-starting-setup/frontend/src:/app/src \
    --rm \
    -d \
    -p 3000:3000 \
    -it \
    goals-react

docker stop mongodb goals-backend goals-frontend

+ 네트워크, Named 볼륨 제거
```
---
## Docker Compose는 무엇이고 왜 사용할까?

- **Docker-Compose는 docker build와 docker run 명령을 대체할 수 있는 도구다.**
  - 다수의 build 명령어와 run 명령어를 하나의 구성 파일로 가진다.
  - 모든 컨테이너를 즉시 시작하고, 모든 이미지를 즉시 빌드하는 자동화된 명령 set이다.
- `누구와도 공유할 수 있는 정의된 언어를 사용하는 구성 파일을 가질 수 있다!`
- **Docker-Compose는 Dockerfiles를 대체하지 않는다. 이미지와 컨테이너를 대체하지도 않는다. 다수의 호스트에서 다중 컨테이너를 다루는데에는 적합하지 않다.**
- 하나의 동일한 호스트에서 다중 컨테이너를 관리할 때 강점을 갖는다.

---

## 어떻게 사용할까? 

- docker-compose.yml 파일 생성하기
- **docker-compose down 시  default가 --rm, -d**
- **docker compose는 모든 service에 대해 새 환경을 자동 생성하고 네트워크에 추가한다**
- Named Volumes는 최상위 volumes에 지정 필요, 다른 서비스들과 공유 가능
- docker compose는 Dockerfile 경로를 주면, 그 파일로 빌드된 이미지가 없더라도 자동으로 빌드해서 사용한다.

```dockerfile
services:
  mongodb:
```
- 이 services 이름을 mongodb로 지정해놓은 구문을 통해 `mongodb://${process.env.MONGODB_USERNAME}:${process.env.MONGODB_PASSWORD}@mongodb:27017/course-goals?authSource=admin`
- 여기에서의 @mongodb에 접근할 수 있게 된다.

```docker-compose
services:
  mongodb:
    image: 'mongo'
    volumes:
      - data:/data/db
    environment:
      - MONGO_INITDB_ROOT_USERNAME=max
      - MONGO_INITDB_ROOT_PASSWORD=secret
   # container_name: mongodb
   # env_file:
   #   - ./env/mongo.env

   # networks:
   #  - goals-net
  backend:
    build: ./backend
   # build:
   #   context: ./backend
   #   dockerfile: DockerFile
   #   args:
   #      some-arg:1
    ports:
      - '80:80'
    volumes:
      - logs:/app/logs    
      - ./backend:/app   # 바인드마운트
      - /app/node_modules
    env_file:
      - ./env/backend.env
    depends_on:
      - mongodb  
  frontend:
    build: ./frontend  # image : ./frontend로 했을 시 invalid reference format 에러 발생
    ports:
      - '3000:3000'
    volumes:
      - ./frontend/src:/app/src
    stdin_open: true  # -it
    tty: true         # -it
    depends_on:
      - backend

volumes:
  data:
  logs:
```

## 어떻게 Docker Compose로 서비스를 시작할까?

- Docker Compose가 존재하는 디렉터리로 이동
- **docker-compose up**
  - 모든 이미지를 가져오고, 컨테이너를 시작
  - -d 옵션 사용 가능
  - --build 옵션 사용하면 강제로 이미지 재 빌드하기 때문에 코드 변경이 일어났을 때 사용하면 된다.
- **docker-compose down**
  - 이 명령은 모든 컨테이너 삭제되고 생성된 디폴트 네트워크와 모든 것 종료
  - 하지만 볼륨은 삭제되지 않는다. 볼륨까지 삭제하려면 -v 옵션 추가 필요