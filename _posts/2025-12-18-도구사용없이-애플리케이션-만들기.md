---
layout: single
title:  "도커를 통해 도구 사용 없이 애플리케이션 만들어보기(PHP,Laravel)"
categories: [docker]
tags: [docker]
toc: true
author_profile: true
---

## 애플리케이션 전체 구조

- 구성할 애플리케이션의 구조는 다음과 같다.
![구조](/assets/images/php.png)

---
## server 컨테이너 구성

```yaml
services:
  server: 
    image: 'nginx:stable-alpine'
    ports:
      - '8000:80'  # 이 포트를 열어두는 이유는? docker hub의 공식 nginx문서에 내부포트 80을 허용한다고 작성되어있음. 
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro  # nginx 공식 문서에 /etc/nginx/nginx.conf 이 경로로 마운트 하라고 작성되어있음.  
#  php:
#  mysql:
# composer:
#  artisan:
#  npm:
```

- server.conf
```
server {
    listen 80;
    index index.php index.html;
    server_name localhost;
    root /var/www/html/public;
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}
```

--- 

## php 컨테이너 구성

- dockerfile 끝에 CMD, ENTRYPOINT가 없으면 base image의 CMD, ENTRYPOINT를 사용한다.

- php.dockerfile

```dockerfile
FROM php:7.4-fpm-alpine

WORKDIR /var/www/html

RUN docker-php-ext-install pdo pdo_mysql
```

- context, dockerfile은 어느 폴더에서, 어떤 파일이 설계도인지를 알려주는 문법이다.
```yaml
services:
  server: 
    image: 'nginx:stable-alpine'
    ports:
      - '8000:80'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
  php:
    build: 
      context: ./dockerfiles
      dockerfile: php.dockerfile
    volumes: ./src:/var/www/html:delegated  # delegated - 성능 향상 옵션
#  mysql:
# composer:
#  artisan:
#  npm:
```

- php 컨테이너와 통신하는 것은 nginx 서버이다.
- port 9000을 열어두는 것은 github의 docker-library의 php에서 찾을 수 있다.
- **nginx.conf 파일의 fastcgi_pass php:3000; 부분을 fastcgi_pass php:9000으로 변경**
  - 이유는? 
  - php 처리 요청이 오면, php라는 이름을 가진 서비스의 9000번 포트로 보내라.
  - php 컨테이너는 9000포트에서 요청을 기다리고 있기 때문에, nginx가 php컨테이너의 9000번 포트로 보내주어야 통신이 가능하다.


---

## mysql 컨테이너 구성


```yaml
services:
  server: 
    image: 'nginx:stable-alpine'
    ports:
      - '8000:80'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
  php:
    build: 
      context: ./dockerfiles
      dockerfile: php.dockerfile
    volumes:
      - ./src:/var/www/html:delegated
  mysql:
    image: mysql:5.7
    env_file:
      - ./env/mysql.env
# composer:
#  artisan:
#  npm:
```


- mysql.env의 변수 이름들은 docker hub의 공식 Mysql 이미지에서 확인 가능


```
MYSQL_DATABASE=homestead 
MYSQL_USER=homestead
MYSQL_PASSWORD=secret
MYSQL_ROOT_PASSWORD=secret
```

---

## composer 컨테이너 구성
- composer.dockerfile

```dockerfile 
  FROM composer

  WORKDIR /var/www/html

  ENTRYPOINT [ "composer", "--ignore-platform-reqs" ]
```

```yaml
services:
  server: 
    image: 'nginx:stable-alpine'
    ports:
      - '8000:80'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
  php:
    build: 
      context: ./dockerfiles
      dockerfile: php.dockerfile
    volumes:
      - ./src:/var/www/html:delegated
  mysql:
    image: mysql:5.7
    env_file:
      - ./env/mysql.env
  composer:
    build:
      context: ./dockerfiles
      dockerfile: composer.dockerfile
    volumes:
      - ./src:/var/www/html
#  artisan:
#  npm:

```

---

## 이렇게만 설정해두고, 컨테이너를 실행해본다면?

- composer 단일 컨테이너만 실행하기 위해서 docker compose run 명령어 사용
- docker compose run --rm composer create-project --prefer-dist laravel/
  laravel . 
  - . 은 프로젝트가 생성될 폴더이고, 이 컨테이너는 내부적으로 /var/www/html이 루트폴더이고, laravel 프로젝트가 생성되는 루트 폴더가 된다.
  - 또한 호스트 머신의 src 폴더와 마운트되어있기 때문에 src 폴더에 반영된다.
- src 폴더에 생긴 .env 파일을 이렇게 수정한다.
```
DB_CONNECTION=mysql
DB_HOST=mysql       # mysql의 서비스 이름 사용, 같은 네트워크에 있기 때문에 도커가 이를 IP 주소로 변환 할 수 있다. 
DB_PORT=3306
DB_DATABASE=homestead
DB_USERNAME=homestead
DB_PASSWORD=secret
```

- docker compose 파일의 server 서비스에 볼륨 하나 더 추가
- 이유는? 
  - 추가하지 않는다면, server는 현재 소스코드에 대해 아무것도 모르고 있는 상태이기 때문이다.
  - server가 소스코드에 대해 알아야, 요청이 들어오는 파일을 처리해 줄 수 있다.
```yaml
services:
  server: 
    image: 'nginx:stable-alpine'
    ports:
      - '8000:80'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./src:/var/www/html 
```


- 이제는 유틸리티 서비스인 composer을 제외하고 server, php, mysql 서비스만 실행하고 싶다. 어떻게 해야할까?
  - **docker compose up -d server php mysql 사용**
- 하지만 이렇게 실행하면 에러가 발생한다.

---
 

## 문제점 발생 및 해결

- Parse error: syntax error, unexpected '|', expecting variable (T_VARIABLE) in /var/www/html/vendor/laravel/prompts/src/helpers.php on line 16 에러 발생
  - 이는 php 7.4버전을 사용해서 사용중인 소스 코드의 문법을 지원하지 못해서 발생하는 버전 불일치 오류
  - php:8.2-fpm 으로 수정
- SQLSTATE[42S02]: Base table or view not found: 1146 Table 'homestead.sessions' doesn't exist (Connection: mysql, SQL: select * from `sessions` where `id` = ABUFuXqAWD9cIpFlZZwAzOB6HtwB6lnucxvGF9RV limit 1)
  - 이는 마이그레이션 문제로 Laravel의 세션을 database에 저장하려고 하는데, 테이블이 없기 때문에 발생한 문제이다. 
  - SESSION_DRIVER=file로 수정하여 해결하였다.
- ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro 
  - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro 로 수정


```yaml
services:
  server: 
    image: 'nginx:stable-alpine'
    ports:
      - '8000:80'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      - ./src:/var/www/html
    depends_on:
      - php
      - mysql
```

- depends_on을 추가하여 server가 시작될 때 의존하는 서비스도 같이 불러오게 만든다.
  - 이를 통해 docker compose up -d server로 간략하게 줄일 수 있다.
- docker compose up -d --build server 명령어는 이미지가 변경되었다면 이미지를 리빌드하고 그 이미지를 사용한다.

---

## 더 많은 유틸리티 컨테이너 사용 (artisan, npm)


```yaml
  artisan:
    build: 
      context: ./dockerfiles
      dockerfile: php.dockerfil
    volumes:
      - ./src:/var/www/html
    entrypoint: ["php", "/var/www/html/artisan"]
```
- entrypoint는 dockerfile에 ENTRYPOINT가 없어도, 이를 오버라이드하여 추가할 수 있다.


```yaml
 npm:
    image: node:14
    working_dir: /var/www/html
    entrypoint: ["npm"]
    volumes:
      - ./src:/var/www/html
```

- Dockerfile 사용하지 않고, docker-compose.yml 파일에서 working_dir 오버라이딩 가능하다.
- docker compose run --rm artisan migrate

---

## Bind Mount와 COPY

- nginx.dockerfile


```dockerfile
FROM nginx:stable-alpine

WORKDIR /etc/nginx/conf.d

COPY nginx/nginx.conf .

RUN mv nginx.conf default.conf        # /etc/nginx/conf.d에 있는 nginx.conf의 이름을 default.conf로 변경

WORKDIR /var/www/html

COPY src .
```

- 이렇게 구성함으로써 바인드 마운트를 사용하지 않고 소스코드의 스냅샷을 이미지에 복사하도록 할 수 있다.
- 바인드 마운트는 개발하는데에 유용하다. 하지만 배포해야 될 때면 사용 할 수가 없다.
- nginx 폴더는 dockerfiles 폴더 외부에 존재하고 있다. 
  - **dockerfiles를 context로 설정하다면 dockerfile이 dockerfiles 폴더에 빌드되는데, nginx와 src에는 접근 할 수 없으므로 빌드에 실패한다.**
  - 해결은? context를 . 로 설정 및 dockerfile: dockerfiles/nginx.dockerfile로 dockerfile의 경로를 추가한다.

```yaml
   server: 
   # image: 'nginx:stable-alpine'
    build: 
      context: .
      dockerfile: dockerfiles/nginx.dockerfile
    ports:
      - '8000:80'
   # volumes:
   #   - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
   #   - ./src:/var/www/html
    depends_on:
      - php
      - mysql
```

- php.dockerfile

```dockerfile
FROM php:8.2-fpm

WORKDIR /var/www/html

COPY src .

RUN docker-php-ext-install pdo pdo_mysql
```

```yaml
 php:
    build: 
      context: .
      dockerfile: dockerfiles/php.dockerfile
   # volumes:
   #   - ./src:/var/www/html:delegated
```

- 바인드 마운트를 없애면 소스코드의 변경 사항이 반영되지 않는다.
- 이렇게 설정하고 실행하면 Permission denied 에러 발생
  - 이유는? 
  - 컨테이너가 읽고 쓰기가 가능해지면, 이미지가(php:8.2-fpm) 컨테이너의 읽기 및 쓰기를 제한한다.
  - 해결은? 
  - 특정 폴더에 대한 쓰기 권한 허용하기
  - php.dockerfile 마지막에 `RUN chown -R www-data:www-data /var/www/html` 이 명령 추가
  - 이 명령은 chown -R 옵션을 통해 지정한 폴더 안에 있는 하위 디렉터리와 파일들까지 소유권을 www-data에게 주는 것이다.
  - www-data는 php 이미지에 설정되어있는 디폴트 유저 이름이다.

- **개발중에는 바인드 마운트를 사용하고, 배포 할 때에는 COPY를 사용한다**