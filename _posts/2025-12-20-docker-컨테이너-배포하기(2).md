---
layout: single
title:  "Docker 컨테이너 배포하기(2)"
categories: [docker]
tags: [docker]
toc: true
author_profile: true
---

## Docker 컨테이너 배포하기(1)의 배포 방식의 단점

- do-it-yourself로 모든 일을 스스로 해야함
- 원격 머신에 대한 책임은 내가 100% 가진다.
- 최신버전으로 유지 필요
- 서버 관리
- 방화벽 관리
- 네트워크 관리
- 모든 걸 알고있다면 괜찮을 수 있겠지만, 만약 모른다면? 

---

## 수동 배포에서 관리형 서비스로(AWS ECS)

- ECS(Elastic Container Service)
- 업데이트, 모니터링, 스케일링, 컨테이너 관리를 단순화 시켜준다
- 도커를 원격에 설치하지 않고, 클라우드를 사용해서 작업을 단순화한다.
- 클러스터, 컨테이너, Task, 서비스
- **컨테이너에서는 docker run과 관련된 방법을 정의한다.**
  - 여러 세부 설정 사항들이 있고, 나중에 실제 사용할 때 경험해보자.
- **Task는 앱의 청사진이다.**
  - AWS에 컨테이너를 시작하는 방법을 알릴 수 있다.(서버 구성)
  - 컨테이너의 묶음이다. 하나의 Task 안에 웹 서버 컨테이너와 로그 수집용 컨테이너를 같이 넣을 수 있다.
  - Fargrate를 통해 이 Task 하나를 가상의 독립 공간에서 돌아간다.
  
- **서비스는 이 구성된 앱과 이를 포함하는 컨테이너를 실행하는 방법을 구성한다.**
  - ex) 로드 밸런서 추가
  - 모든 Task가 서비스에 의해 실행된다.
- **클러스터는 서비스가 실행되는 전체 네트워크다.**
- Public IP를 통해 애플리케이션을 확인할 수 있다.
- 어떤 커스텀 서버나 머신을 시작하지 않고도 앱을 배포 할 수 있다.

---

## 컨테이너 업데이트는 어떻게 할까? 

- docker build로 새로운 이미지 빌드
- docker tag를 통해 이미지 이름 변경(v1,v2...)
- docker push를 통해 Docker Hub에 업데이트 된 이미지 업로드
- ECS task에 들어가서 이미지 주소를 v2인 이미지로 수정하고, 업데이트한다.
- 혹은 force deployment

--- 

## 다중 컨테이너 배포

- Docker-compose는 사용하지 않는다. 
  - `docker compose는 로컬 환경에서 다중 컨테이너 실행 할 때 편리`
- 클라우드를 사용 때에는 컨테이너의 각각 인스턴스들은 클라우드 provider에 의해 실행되고 관리된다.
  - 그리고 항상 동일한 컴퓨터에서 실행되는 것은 아니다.
  - **그렇기에 컨테이너들끼리의 네트워크에 연결될 때, mongodb 이런식으로 입력해놓아도 알아서 컨테이너의 IP주소를 매핑해서 실행해주는 Docker의 기능은 사용할 수 없다.**
  
- 하지만 ECS에서는 동일한 Task에 컨테이너를 추가하면 같은 컴퓨터에서 실행이 보장된다.
  - 그래도 여전히 ECS는 네트워크를 생성하지 않고, localhost를 컨테이너 애플리케이션 코드 내부의 주소로 사용할 수 있게 해준다.
```
mongoose.connect(
  `mongodb://${process.env.MONGODB_USERNAME}:${process.env.MONGODB_PASSWORD}@mongodb:27017/course-goals?authSource=admin`,
  {
``` 
이 코드를 환경변수로 바꿔준다.
```
mongoose.connect(
  `mongodb://${process.env.MONGODB_USERNAME}:${process.env.MONGODB_PASSWORD}@${process.env.MONGODB_URL}:27017/course-goals?authSource=admin`,
  {
```
그 뒤, env파일,Dockerfile에 추가한다.
```
MONGODB_USERNAME=max
MONGODB_PASSWORD=secret
MONGODB_URL=mongodb
```
```dockerfile
ENV MONGODB_USERNAME=root
ENV MONGODB_PASSWORD=secret
ENV MONGODB_URL=mongodb
```
또한 Task 설정에서 Key, value를 추가해준다.

- 여기서 중요한 것은, backend 컨테이너의 일부분인 mongodb 컨테이너를 추가하기 위해서 MONGODB_URL의 Value는 localhost로 설정해준다.
  - 그럼 프로덕션 환경에서는 MONGODB_URL의 값으로 localhost를 사용하고, 개발중에는 mongodb를 value로 사용한다.
- 강의에서는 이렇게 실행했지만 프로덕션 환경에서는 AWS RDS를 사용하고, 그 주소를 확인하여 환경변수에 value에 넣어준다.
  - 그 이유는? 만약 백엔드 컨테이너가 10개로 늘어난다면, 같은 Task에 묶여있는 DB도 강제로 10개가 생겨버리기 때문에, 비효율 적이기에 DB를 Task 밖으로 뺀다.
- Task에 mongodb 컨테이너를 추가하기
- 그 뒤, Service 및 로드 밸런서 생성하기
  - Load balancer : 트래픽 효율적 처리 및 도메인 할당(입구에서 대기하면서 골고루 트래픽 분산시키는 작업, 80,443 port 사용)
    - Public IP주소와 컨테이너는 죽고 생성될 때마다 IP가 계속 바뀌지만, 로드 밸런서는 고정된 주소를 재공하기에 사용자는 이 주소에 요청을 보내면 된다.
  - Auto Scaling : 트래픽 증가에 따라 더 많은 동시 컨테이너 인스턴스 실행되도록 구성

---

## ECS로 EFS 볼륨 사용하기 

- 문제점
    - fargate - 사용자가 관리해야 할 서버 없이 실행 (Serverless)
    - 새 컨테이너 이미지를 사용하려고 하면 기존의 실행되던 서비스는 업데이트되며, Task는 재시작되고 모든 데이터가 손실된다.
    - 해결은?
    - EFS(Elastic File System): 서버없이 실행되는 컨테이너에 파일 시스템 연결하는 것을 가능하게 하는 볼륨 추가하기
      - 1. 파일 시스템 생성(ECS와 동일한 VPC 사용)
      - 2. 새로운 보안 그룹 만들기(인바운드 NFS, 사용중인 보안 그룹 Source로 설정), 이 설정은 사용중인 보안 그룹에서 실행중인 컨테이너가 만들고 있는 보안 그룹에서 실행중인 모든 것과 통신 허용하는 규칙, 2049포트에서 생성(EFS가 사용)
      - 3. EFS에 보안 그룹 설정해주고 생성하기
      - 4. ECS에 파일 시스템 설정하기
      - 5. Task의 컨테이너에 파일 시스템 설정하기


### Fargate란? 

- 사용자가 관리해야 할 서버가 없는 방식
- EC2방식 vs Fargate 방식
  - 내가 직접 사양 고르고, 리눅스 설치하고, 도커 설치하고, 보안 패치 하는 방식 vs 도커 이미지와 필요한 사양만 알려주고, AWS가 알아서 컨테이너를 실행하고 관리하는 방식
- 장점은?
  - 인프라 관리 : 리눅스 커널 업데이트, 보안 패치 등을 AWS가 알아서 진행
  - 유연한 비용 : EC2는 켜두기만 해도 비용 발생, Fargate는 컨테이너가 실제로 돌아가는 시간만큼만 비용 발생
  - 확장성 : 트래픽 증가 시 Fargate가 알아서 컨테이너 개수 증가시켜 대응
- Lambda vs Fargate
  - 아주 짧은 코드 실행, 실행 시간 짧고 가벼움 vs 도커 컨테이너 전체 실행, 웹 서버처럼 24시간 켜져 있어여 하거나 복잡한 앱 돌릴 때 사용