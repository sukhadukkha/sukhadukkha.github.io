---
layout: single
title:  "Docker 컨테이너 배포하기(3)"
categories: [docker]
tags: [docker]
toc: true
author_profile: true
---


## 배포 시 자체 DB를 사용하고 관리하는 것의 단점

- Do It Yourself
- 확장 및 관리의 어려움
- 트래픽 급증시 성능 문제 발생 가능
- 백업과 보안 문제
- EC2 vs ECS와 마찬가지로 하는 일 모든 것을 알고 있고 제어할 수 있다면 괜찮지만, 전문가가 아니라면 문제가 발생 할 것이다.

---

## 관리형 DB서비스 사용

- AWS RDS (Relational Database Service) : 관계형 DB 서비스
- MongoDB Atlas (MongoDB에서 제공)

---

## 강의에서의 예제인 MongoDB Atlas 사용 간단히 정리해보기

- 개발에서는 MongoDB 컨테이너를, 배포에는 MongoDB Atlas를 사용할 수 있다.
  - MongoDB Atlas의 Cluster 버전과 MongoDB 이미지의 버전을 동일하게 맞추어야 한다.
- 강의에서는 모든 환경을 다 클라우드 DB를 사용했다.
- MongoDB Atlas에 접근하려면 Network Access에서 접근 가능 IP와 사용자를 추가하고 구성해야 한다.
- docker-compose에서 더이상 mongodb 컨테이너는 필요 없어지고, 환경변수들을 설정하고 MongoDB Atlas에 접근할 수 있게 되었다.
- EFS도 더 이상 필요 없고, MongoDB Atlas가 알아서 데이터들을 관리한다.

---

## 개발 vs 프로덕션 DB 운영

1. 서비스 종류는 동일하게, 사양만 다르게
   - 개발과 프로덕션 환경 모두 AWS RDS를 사용하고, 사양만 다르게 설정
   - 환경 불일치로 인한 버그 최소화 가능
   - Prod: 자동백업, 고성능, 대용량 스토리지 사용
   - Dev: 가장 낮은 사양, 백업 미실시, 단일 인스턴스 사용 등
2. 개발은 Docker, 배포는 RDS 
   - 개발 단계에서는 로컬이나 개발 서버의 Docker 컨테이너로 DB를 띄우고, 실제 배포 시에만 RDS 등 서비스 사용
   - 개발 단계에서 비용 발생 X
   - Prod: AWS RDS 사용
   - Dev: docker-compose를 사용하여 DB컨테이너 실행
   - 도커 이미지 버전과 RDS 엔진 버전 다르다면 배포 후 문제 발생 가능

- 소스 코드에는 주소를 직접 적지 않고, 환경 변수를 통해 각 환경에 맞는 DB 주소를 주입하는 것이 중요하다!
- Terraform을 사용하면 코드를 통해 환경에 따라 다른 DB를 생성화하도록 자동화 할 수 있다.
```
예시: 테라폼(Terraform)이나 ECS 설정 시 환경별 주소 주입
MONGODB_URL=localhost            # 개발 환경(Local)
MONGODB_URL=dev-db.aws.com       # 개발 환경(Cloud)
MONGODB_URL=prod-db.aws.com      # 운영 환경(Cloud)
```

---

## React SPA 배포하기

- "start": "react-scripts start" 즉 npm start에는 개발용 서버가 내장되어 있다. 하지만 무겁고, 다른 여러가지 문제들로 인해 배포용으로는 사용하지 않는다.
- 이를 해결하기 위해 "build": "react-scripts build" 를 통해 가볍고 최적화된 빌드된 파일을 build라는 폴더 안에 생성하고, 이 파일들을 Nginx 같은 웹 서버 컨테이너나, AWS S3 같은 서비스에 올려 사용한다.


### Multi Stage Build

- Multi Stage Build를 사용하면 여러 빌드 단계 또는 설정 단계를 정의하는 하나의 Dockerfile을 만들 수 있다.
- Multi Stage Build 에서는 CMD가 아닌 RUN을 사용한다.
- 스테이지는 서로의 결과를 복사할 수 있다.
- --from=스테이지 : 스테이지에서 최종 콘텐츠를 복사한다는 의미
- docker build --target build -f frontend/Dockerfile.prod ./frontend 를 통해 원하는 스테이지만 빌드 가능 가능(--target)

```dockerfile
FROM node:14-alpine as build

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

RUN npm run build

FROM nginx:stable-alpine

COPY --from=build /app/build /usr/share/nginx/html

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]

```

```
const response = await fetch('http://localhost/goals');
```

- localhost는 틀린 주소 -> Task나 컨테이너, ECS 서버가 아닌 로컬 머신을 참조하기 때문에 변경 필요함
- 강의에서는 backend와 동일한 서버에 배포하기 위해 /goals로 변경

- docker build -f frontend/Dockerfile.prod -t 내 저장소 이름 ./frontend로 이미지 빌드 한 뒤, Docker Hub에 push
- **동일한 Task에서 같은 포트를 2개 이상 사용할 수 없다**
  - 프론트엔드, 백엔드 컨테이너를 하나의 컨테이너로 합치기 (백엔드에서 Node 서버를 사용하기 때문에 가능)
  - 백엔드의 포트 변경하기 (혼란스러움)
- 위의 두 가지 방법을 사용하지 않고 StandAlone 형식을 사용하기 위해서는 새로운 Task 만들기 필요
  - frontend, backend 각각의 URL이 생성됨
  - frontend와 backend가 다른 URL에서 제공되기 때문에 브라우저가 /goals를 찾을 수 없음
- React 코드에서는 환경변수 사용 불가
  - 코드가 브라우저에서 실행되기 때문
- 하지만 React 프로젝트 설정은 환경 변수를 지원한다.

```
const backendUrl = process.env.NODE_ENV === 'development' ? 'http://localhost' : '백엔드 로드 밸런서 주소'
# npm start = development 값, npm build = production 값 갖는다.

const response = await fetch(backendUrl + '/goals');
```

- frontend 로드 밸랜서 생성, 서비스 생성

--- 

## 최종 아키텍처

![구조](/assets/images/Architecture.png)
