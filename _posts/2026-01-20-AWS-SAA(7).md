---
layout: single
title:  "AWS SAA 준비(RDS, Aurora, RDS Security, RDS Proxy, ElastiCache)"
categories: [AWS SAA]
tags: [AWS SAA]
toc: true
author_profile: true
---

## Amazon RDS(Relational Database Service)

- AWS에서 제공하는 관리형 관계형 DB 서비스다. 사용자가 직접 EC2에 DB를 설치하고 운영하는 번거로움을 줄여주며, 패치, 백업, 복구 등을 AWS가 대신 처리한다.
- 지원 엔진: MySQL, PostgreSQL, MariaDB, Oracle, SQL Server, Amazon Aurora.
- 장점: 클릭 몇 번으로 고성능 DB를 구축할 수 있고, 인프라 관리보다는 쿼리 최적화나 데이터 모델링 등 개발 본연의 업무에 집중하게 해준다.

### Multi-AZ (고가용성 - High Availability)

- 장애 복구를 위한 기능이다.
- **주 데이터베이스(Primary) 외에 다른 가용 영역(AZ)에 똑같은 대기용(Standby) 인벤토리를 하나 더 두는 방식이다.**
- **동기식 복제 (Synchronous): 데이터가 주 DB에 써질 때 대기용 DB에도 동시에 기록된다. 따라서 데이터 일관성이 완벽하다.**
- 자동 장애 조치 (Failover): 주 DB에 문제가 생기면 AWS가 자동으로 DNS를 변경하여 대기용 DB를 주 DB로 승격시킨다. 서비스 중단 시간을 최소화한다.
- 용도: 성능 향상이 아닌, 서비스 안정성과 가용성이 최우선일 때 사용한다.

### Read Replicas (읽기 전용 복제본 - Scalability)

- 읽기 성능을 높이기 위한 기능이다. 주 DB의 데이터를 복제한 별도의 읽기 전용 DB 인스턴스를 생성한다.
- **비동기식 복제 (Asynchronous): 주 DB에 데이터가 기록된 후 약간의 시차를 두고 복제본에 반영된다. (최종 일관성)**
- 성능 분산: SELECT 같은 읽기 요청은 복제본으로 보내고, INSERT/UPDATE/DELETE 같은 쓰기 요청은 주 DB가 처리하게 하여 부하를 분산한다.
- 특징: 최대 15개까지 생성 가능하며, 필요 시 독립된 DB로 승격(Promote)시킬 수 있다.
- 범위: 동일 리전뿐만 아니라 다른 리전(Cross-Region)에도 생성할 수 있다.
- 비용 최적화: Read Replicas는 동일 가용 영역 내에서 생성하면 데이터 전송 비용이 무료지만, 다른 가용 영역이나 리전으로 보내면 비용이 발생할 수 있다.

## Amazon Aurora

- AWS가 클라우드 환경에 최적화하여 직접 설계한 관계형 데이터베이스(RDB) 엔진이다. MySQL 및 PostgreSQL과 완벽하게 호환되면서도 기존 오픈소스 DB보다 훨씬 뛰어난 성능과 가용성을 제공한다.
- 핵심 특징
  - 압도적 성능: 표준 MySQL보다 최대 5배, PostgreSQL보다 최대 3배 빠르다.
  - 클라우드 네이티브 스토리지: 데이터베이스 엔진과 저장소(Storage)를 분리하여 설계했다. 저장소는 자동으로 확장되며, 최대 128TB까지 늘어난다.
  - 호환성: 코드를 수정할 필요 없이 기존 MySQL이나 PostgreSQL 앱을 그대로 가져와 쓸 수 있다.
- 주요 동작
  - Aurora는 일반 RDS와 데이터를 저장하는 방식부터 다르다.
  - 6-Way 복제: 데이터를 3개의 가용 영역(AZ)에 걸쳐 6개의 복사본으로 자동 저장한다.
  - 2개의 데이터 복사본이 손실되어도 쓰기가 가능하고, 3개의 데이터 복사본이 손실되어도 읽기가 가능하다.
  - 자가 치유(Self-healing) 스토리지: 데이터 블록의 오류를 자동으로 감지하고 백그라운드에서 복구한다.
  - 빠른 장애 조치(Failover): 일반 RDS는 수 분이 걸릴 수 있는 반면, Aurora는 보통 30초 미만에 장애 조치가 완료된다.
- 엔드포인트 시스템
  - Writer Endpoint: 항상 하나의 '주 인스턴스(Primary)'를 가리킨다. 쓰기 작업에 사용된다.
  - Reader Endpoint: 여러 개의 '읽기 복제본(Aurora Replicas)' 사이에서 로드 밸런싱을 수행한다. 읽기 작업에 사용된다.
    - Aurora Replicas: 최대 15개까지 생성 가능하며, 복제 지연(Lag)이 10~20ms 수준으로 매우 짧다.
- Aurora의 특수 기능
  - Aurora Serverless: 트래픽에 따라 DB 용량을 자동으로 늘리고 줄인다. 트래픽이 전혀 없을 때는 아예 0으로 내려 비용을 절감할 수 있다. (간헐적인 워크로드에 최적)
  - Aurora Global Database: 전 세계 여러 리전에 데이터를 복제하여 대기 시간을 줄이고 리전 단위 장애에 대비한다.
  - Backtrack: 실수를 했을 때 특정 시점으로 데이터를 '되감기'하는 기능이다. (백업 복원보다 훨씬 빠름)

## 데이터 폭증 상황의 RDS, Aurora

- 데이터 폭증 상황 2가지
  - 물리적인 용량 부족
  - 처리 성능 부족
- `RDS를 사용할 때의 해결`
- 물리적인 데이터 양이 늘어날 때(Storage 부족)
  - 해결 방법: RDS 스토리지 자동 확장(Storage Auto-scaling)을 활성화하거나 수동으로 할당된 스토리지를 늘린다.
  - 주의점: 인스턴스 개수(Read Replicas)를 늘리는 것은 해결책이 아니다. 읽기 복제본은 원본 데이터를 그대로 복사하기 때문에, 원본 디스크가 꽉 차면 복제본들도 똑같이 용량 부족 문제를 겪게 된다.
  - 결과: 디스크 용량 자체가 $100GB \rightarrow 500GB$ 식으로 늘어난다.
- 트래픽이나 쿼리 부하가 늘어날 때(Performance 부족)
  - A. 수직 확장 (Scale-up: 인스턴스 사양 변경)
  - 해결 방법: 인스턴스 타입을 더 높은 사양으로 변경한다 (예: db.t3.micro $\rightarrow$ db.m5.large).
  - 용도: 쓰기(Write) 작업이 너무 많거나, 복잡한 Join 연산으로 CPU/RAM이 모자랄 때 사용한다.용도: 쓰기(Write) 작업이 너무 많거나, 복잡한 Join 연산으로 CPU/RAM이 모자랄 때 사용한다.
  - B. 수평 확장 (Scale-out: 인스턴스 개수 추가)
  - 해결 방법: Read Replicas(읽기 복제본)를 생성한다.
  - 용도: 단순 조회(SELECT) 요청이 폭주할 때 사용한다. 메인 DB는 쓰기만 전담하고, 조회는 여러 대의 복제본이 나누어 처리하게 된다.
- `Aurora를 사용할 때의 해결`
  - 용량: 스토리지가 최대 128TB까지 자동으로 늘어나므로 사용자가 신경 쓸 필요가 없다.
  - 성능: Reader Endpoint 하나로 최대 15개의 읽기 복제본을 묶어 관리할 수 있어 수평 확장이 매우 간편하다.

### RDS 및 Aurora 백업 (Backups)

- RDS, Aurora는 둘 다 자동 백업과 수동 스냅샷 기능을 제공하지만, 내부 작동 방식에 차이가 있다.
- 자동 백업 (Automated Backups)
  - RDS: 매일 정해진 백업 시간(Backup Window) 동안 전체 스냅샷을 찍고, 5분마다 트랜잭션 로그를 기록한다. 보존 기간은 1~35일이다.
  - Aurora: 백업 시간을 따로 설정할 필요 없이 데이터가 스토리지에 기록되는 즉시 지속적이고 점진적으로 백업이 이루어진다. 스토리지 계층에서 처리되므로 DB 성능에 전혀 영향을 주지 않는다.
- 수동 스냅샷 (Manual Snapshots)
  - 사용자가 직접 원하는 시점에 생성한다.
  - 자동 백업과 달리 사용자가 직접 삭제하기 전까지 영구적으로 보존된다.
  - 비용 아끼는 방법 : 한 달에 만약 2시간만 RDS를 사용한다면, DB를 계속 켜둘 필요 없이(켜진 시간 동안 계속 비용 발생) 스냅샷을 찍고, 인스턴스를 삭제한다. 다음에 사용할 때, 스냅샷을 이용해 복구하는 방법으로 비용 절약을 할 수 있다.
- 데이터 보존: DB 인스턴스를 삭제하면 자동 백업도 같이 삭제된다. 하지만 삭제 직전 '최종 스냅샷(Final Snapshot)'을 찍도록 설정하여 데이터를 보호할 수 있다.

### 복구 옵션 (Restore Options)

- 데이터베이스에 문제가 생겼을 때 선택할 수 있는 복구 방법들이다. 복구 시에는 항상 기존 DB를 덮어쓰는 것이 아니라 새로운 DB 인스턴스가 생성된다는 점을 명심해야 한다.
- 스냅샷 복원 (Restore from Snapshot)
  - 특정 시점에 저장된 수동 스냅샷이나 자동 스냅샷을 기반으로 새 인스턴스를 생성한다.
- 특정 시점 복구 (Point-in-Time Recovery, PITR)
  - 보존 기간 내의 어느 1초 단위 시점으로든 복구할 수 있다.
  - 작동 원리: 가장 최근의 전체 스냅샷을 복원한 뒤, 5분마다 저장된 트랜잭션 로그를 해당 시점까지 순차적으로 적용(Replay)한다.
- 복구와 엔드포인트: 복구를 하면 새로운 DB가 생성되므로, 애플리케이션의 접속 주소(Endpoint)를 새 주소로 바꿔주거나 Route 53을 통해 CNAME을 변경해야 한다.
- Restoring MySQL RDS Database from S3
  - 온프레미스 서버나 EC2에서 운영 중인 MySQL 데이터를 RDS로 옮길 때 사용하는 방식이다. 핵심은 '물리적 백업(Physical Backup)' 파일을 활용한다는 점이다.
  - 사용 도구: 반드시 Percona XtraBackup을 사용하여 백업 파일을 생성해야 한다.
  - 작동 방식
    - 원본 DB 서버에서 xtrabackup 명령어로 전체 백업 파일을 생성한다.
    - 생성된 파일들을 S3 버킷에 업로드한다.
    - RDS 콘솔에서 'Restore from S3'를 선택하고 S3 경로와 IAM 역할을 지정한다.
    - AWS는 S3의 데이터를 읽어 새로운 RDS 인스턴스를 생성한다.
  - 특징: mysqldump 같은 논리적 백업보다 복구 속도가 압도적으로 빠르다. 테라바이트(TB) 단위의 데이터를 옮길 때 유리하다.
  - 복제 본질: 두 방식 모두 기존의 실행 중인 인스턴스에 데이터를 덮어쓰는 것이 아니라, 항상 새로운 리소스(인스턴스 또는 클러스터)를 생성한다.
- Restoring MySQL Aurora Cluster from S3
  - Aurora 역시 S3의 백업 파일을 이용해 클러스터를 생성할 수 있다. RDS MySQL 복구와 유사하지만, Aurora 고유의 스토리지 아키텍처에 맞게 데이터를 구성한다는 차이가 있다.
  - 사용 도구: RDS와 마찬가지로 Percona XtraBackup 파일을 기반으로 한다.
  - 작동 방식
    - S3에 업로드된 XtraBackup 파일을 소스로 지정한다.
    - 복구 과정에서 단일 인스턴스가 아닌 Aurora DB 클러스터를 생성한다.
    - Aurora의 분산 공유 스토리지 레이어로 데이터가 마이그레이션된다.
    - 장점: 일반 RDS로 복구한 뒤 다시 Aurora로 전환하는 번거로움 없이, 처음부터 Aurora 클러스터로 직접 복구할 수 있어 시간을 단축한다.
  - 복제 본질: 두 방식 모두 기존의 실행 중인 인스턴스에 데이터를 덮어쓰는 것이 아니라, 항상 새로운 리소스(인스턴스 또는 클러스터)를 생성한다.
- 이 두 과정은 데이터가 정적(Static)일 때 유용하다. 만약 서비스 중단 없이 실시간으로 변하는 데이터를 마이그레이션해야 한다면 AWS DMS(Database Migration Service)를 함께 사용하는 것이 정석이다. 또한 S3 버킷과 생성될 DB 인스턴스는 반드시 동일한 리전에 있어야 한다.


### Aurora Database Cloning

- 클로닝은 오직 Aurora에서만 지원하는 매우 강력하고 효율적인 기능이다.
- 개념: 기존 DB 클러스터와 동일한 데이터를 가진 새로운 클러스터를 즉시 생성한다.
- Copy-on-Write (CoW) 기술: 클론을 생성하는 시점에는 원본과 데이터를 공유한다. 즉, 추가 스토리지가 필요 없고 비용도 들지 않는다.
  - 데이터가 수정될 때 비로소 수정된 부분만 별도의 블록으로 저장된다.
- 장점: 테라바이트급 대용량 DB도 몇 분 안에 복제할 수 있어, 운영 데이터에 영향을 주지 않고 개발/테스트를 하거나 무거운 분석 쿼리를 돌릴 때 매우 유용하다.
- 클로닝 vs 스냅샷 복원: "운영 데이터의 최신 상태를 복제하여 테스트 환경을 빠르게 구축해야 한다"는 요구사항이 나오면 Aurora Cloning이 정답이다. 스냅샷 복원은 데이터를 새로 복사해와야 하므로 시간이 훨씬 오래 걸린다.

---


## RDS & Aurora Security

- AWS RDS와 Aurora는 데이터의 기밀성, 무결성, 가용성을 보호하기 위해 다층적인 보안 체계를 제공한다. 클라우드 엔지니어로서 인프라를 설계할 때 반드시 고려해야 할 보안 요소를 네트워크, 인증, 암호화, 모니터링의 네 가지 영역으로 나누어 정리한다.
- 네트워크 보안
  - 가장 기본이 되는 보안 계층으로, 외부로부터의 접근을 원천 차단하고 허용된 트래픽만 통과시키는 것이 핵심이다.
  - VPC 격리: DB 인스턴스는 반드시 프라이빗 서브넷(Private Subnet)에 배치한다. 외부 인터넷에서 직접 접속할 수 없도록 격리하는 것이 원칙이다.
  - 보안 그룹 (Security Groups): DB로 들어오는 트래픽(Inbound)을 포트(예: 3306, 5432)와 소스(Source)별로 제한한다.
  - 권장 사항: 특정 IP 주소를 입력하기보다, 애플리케이션 서버(EC2 등)의 보안 그룹 ID를 소스로 지정하는 방식을 사용한다. 이를 통해 오토 스케일링으로 서버 대수가 변해도 보안 설정을 유지할 수 있다.
- 인증 및 권한 관리 (Access Control)
  - 누가 데이터베이스에 접속할 수 있는지를 관리하는 단계다.
  - IAM 데이터베이스 인증: 전통적인 비밀번호 방식 대신 IAM 사용자나 역할을 통해 인증 토큰을 발급받아 접속한다.
    - 장점: 비밀번호를 코드에 노출할 필요가 없으며, 15분만 유효한 임시 토큰을 사용하여 보안성이 높다. 통신은 반드시 SSL/TLS로 암호화된다.
  - AWS Secrets Manager: DB 자격 증명(ID/PW)을 안전하게 저장하고 자동으로 교체(Rotation)해주는 서비스다. 애플리케이션은 비밀번호 대신 Secrets Manager의 ARN을 참조하여 접속 정보를 가져온다.
- 데이터 암호화 (Data Protection)
  - 데이터가 저장되어 있을 때와 전송될 때 모두 보호해야 한다.
  - 저장 시 암호화 (Encryption at Rest): AWS KMS(Key Management Service)를 사용하여 DB 인스턴스, 스냅샷, 백업, 복제본의 데이터를 암호화한다. 인스턴스 생성 시점에 설정해야 하며, 나중에 변경하려면 스냅샷을 찍어 암호화된 상태로 복원해야 한다.
  - 전송 시 암호화 (Encryption in Transit): 클라이언트 애플리케이션과 DB 간의 통신을 SSL/TLS를 통해 암호화한다. AWS는 각 엔진에 맞는 인증서(CA)를 제공하며, 이를 강제하도록 파라미터 그룹에서 설정할 수 있다.
- 모니터링 및 감사 (Monitoring & Auditing)
  - 보안 사고를 예방하고 사고 발생 시 원인을 추적하기 위한 장치다.
  - AWS CloudTrail: RDS 관리 API 호출(예: DB 삭제, 수정) 기록을 모두 로그로 남긴다. 누가 언제 설정을 변경했는지 추적할 수 있다.
  - CloudWatch Logs: 데이터베이스의 에러 로그, 느린 쿼리 로그(Slow Query Logs), 감사 로그(Audit Logs)를 수집하여 분석한다.
  

## Amazon RDS Proxy

- 애플리케이션과 관계형 데이터베이스(RDS 또는 Aurora) 사이에서 데이터베이스 연결(Connection)을 관리하고 효율화하는 완전 관리형 데이터베이스 프록시 서비스다.
- 특히 서버리스 환경(Lambda 등)이나 동시 접속자가 급증하는 애플리케이션에서 데이터베이스의 연결 제한 문제를 해결하기 위해 필수적으로 사용된다.
- 작동 원리
  - 일반적인 아키텍처에서 애플리케이션은 데이터베이스와 직접 연결을 맺는다. 하지만 RDS Proxy를 도입하면 애플리케이션은 프록시와 통신하고, 프록시가 미리 맺어놓은 데이터베이스 연결을 재사용하게 된다.
- 주요 기능 및 장점
  - 연결 풀링 (Connection Pooling)
    - 데이터베이스 연결을 맺고 끊는 과정은 CPU와 메모리 자원을 많이 소모한다. RDS Proxy는 데이터베이스와의 연결을 미리 맺어놓고 이를 풀(Pool) 형태로 관리한다.
    - 효율성: 여러 클라이언트가 소수의 데이터베이스 연결을 공유하여 사용할 수 있다.
    - 확장성: 데이터베이스의 최대 연결 수(Max Connections) 제한을 초과하는 대규모 동시 접속을 처리할 수 있다.
  - 빠른 장애 조치 (High Availability & Failover)
    - 속도: 애플리케이션이 직접 새 인스턴스를 찾는 것보다 최대 60% 이상 빠르게 새로운 대기 인스턴스로 연결을 전환한다.
    - 안정성: 애플리케이션 수준에서는 연결이 끊기지 않고 잠시 대기하는 정도로 느껴지므로 서비스 중단을 최소화한다.
  - 보안 강화 (Security)
    - IAM 인증: 애플리케이션 소스 코드에 데이터베이스 비밀번호를 저장할 필요가 없다. 대신 IAM 역할을 통해 프록시에 접속할 수 있다.
    - Secrets Manager 통합: 데이터베이스 자격 증명(ID/PW)은 AWS Secrets Manager에 안전하게 저장되며, RDS Proxy가 이를 읽어와 데이터베이스에 인증한다.
- 주요 사용 사례: AWS Lambda
  - 서버리스 함수인 Lambda는 실행될 때마다 새로운 연결을 시도하고, 종료될 때 연결을 제대로 닫지 않는 경우가 많다. 이로 인해 '연결 고갈(Connection Exhaustion)' 현상이 자주 발생한다.
  - 해결책: Lambda 앞에 RDS Proxy를 두면, 수천 개의 Lambda 인스턴스가 생성되어도 프록시가 연결을 효율적으로 제어하여 데이터베이스 부하를 막는다.
- 사용 시 고려사항
  - 추가 비용: RDS Proxy 사용에 따른 별도의 시간당 요금과 데이터 처리 비용이 발생한다.
  - 엔드포인트: 애플리케이션의 DB 호스트 주소를 기존 RDS 엔드포인트가 아닌 RDS Proxy 엔드포인트로 변경해야 한다.
  - 고정된 연결 (Pinning): 특정 쿼리(예: 임시 테이블 사용)를 실행하면 프록시가 연결을 공유하지 못하고 특정 세션에 고정하는 'Pinning' 현상이 발생할 수 있으므로 주의가 필요하다.


## AWS ElastiCache

- 클라우드에서 인메모리(In-memory) 데이터 스토어 또는 캐시를 간편하게 설정, 운영 및 확장할 수 있게 해주는 완전 관리형 서비스다. 데이터베이스의 부하를 줄이고 애플리케이션의 응답 속도를 획기적으로 개선하기 위해 사용된다.
- 핵심 개념 및 작동 원리
  - 일반적인 디스크 기반 데이터베이스(RDS 등)와 달리 데이터를 메모리(RAM)에 저장한다. 이로 인해 읽기/쓰기 작업 시 마이크로초(μs) 단위의 지연 시간을 제공한다.
  - 캐싱 아키텍처: 애플리케이션은 먼저 ElastiCache에 데이터가 있는지 확인(Cache Hit)하고, 없으면(Cache Miss) 그때서야 실제 DB(RDS)에 접근하여 데이터를 가져온 뒤 다시 캐시에 저장한다.
- 지원 엔진: Redis vs Memcached

  | 비교 항목 | Redis | Memcached |
  |-----------|-------|-----------|
  | 데이터 구조 | 문자열, 리스트, 셋, 해시, 정렬된 셋 등 다양함 | 단순한 Key-Value (문자열 중심) |
  | 영속성 (Persistence) | 데이터 백업 및 복구 지원 (AOF, Snapshot) | 지원 안 함 (메모리 휘발성) |
  | 고가용성 | Multi-AZ, 복제본(Replica) 지원 | 지원 안 함 |
  | 확장성 | 수평 확장(Cluster Mode) 지원 | 수평 확장(노드 추가) 지원 |
  | 주요 용도 | 캐시, 세션 관리, 리더보드, 실시간 채팅, Pub/Sub | 단순한 데이터 캐싱, 대규모 객체 캐싱 |

- 활용 사례
  - DB 부하 분산: 자주 조회되는 데이터(공지사항, 인기 게시물 등)를 캐싱하여 RDS의 읽기 트래픽을 줄인다.
  - 세션 스토어 (Session Store): 사용자의 로그인 상태나 장바구니 정보를 저장한다. 서버가 여러 대인 분산 환경에서 세션 정합성을 유지하기 위해 필수적이다.
  - 리더보드 (Sorted Sets): Redis의 정렬된 셋(Sorted Sets) 기능을 사용하여 게임 스코어 순위 등을 실시간으로 계산하고 제공한다.
  - 속도 제한 (Rate Limiting): 특정 API에 대한 요청 횟수를 메모리 기반으로 빠르게 카운트하고 제한한다.

- 캐싱 전략
  - Lazy Loading
    - 요청이 들어올 때만 캐시에 데이터를 채우는 방식이다.
    - 캐시 미스가 발생하면 지연 시간이 생길 수 있지만, 불필요한 데이터를 미리 캐싱하지 않아 메모리가 효율적이다.
  - Write-through
    - 데이터가 DB에 업데이트될 때 캐시도 동시에 업데이트한다.
    - 캐시의 데이터가 항상 최신 상태를 유지하지만, 쓰기 작업 시 지연 시간이 늘어날 수 있다.
- 시험 및 실무 활용
  - 고가용성이 중요하다면? 무조건 Redis를 선택하고 Multi-AZ를 활성화해야 한다.
  - 단순하고 빠른 확장이 필요하다면? 멀티스레드를 지원하는 Memcached가 유리할 수 있다.
  - 데이터 유실을 방지해야 한다면? Redis의 스냅샷 기능을 활용한다.
  - 비용 최적화: ElastiCache도 Reserved Instances(RI)를 지원하므로, 사용량이 일정한 경우 비용을 크게 절감할 수 있다.