---
layout: single
title:  "AWS SAA 준비(SQS, SNS, Kinesis Data Streams, Data Firehose, MQ)"
categories: [AWS SAA]
tags: [AWS SAA]
toc: true
author_profile: true
---


## Amazon SQS

- 기본 아키텍쳐

![구조](/assets/images/SQS.png)

- SQS Queue 대기열에 따른 Auto Scaling
  - 웹사이트 트래픽이 많아진다 -> SQS queue 길이가 길어진다 -> Alarm이 ASG에 전송되고 자동으로 스케일링한다.

![구조](/assets/images/SQS-Auto-Scaling.png)


- 분산 시스템 및 마이크로서비스 아키텍처에서 메시지를 주고받을 수 있게 해주는 완전 관리형 메시지 큐 서비스다.
- 핵심 개념: 왜 사용하는가?
  - 디커플링(Decoupling): 구성 요소들이 서로를 직접 호출하지 않고 큐를 통해 통신하므로, 한 곳에 장애가 발생해도 전체 시스템이 무너지지 않는다.
  - 확장성(Scalability): 트래픽이 급증할 때 메시지를 큐에 쌓아두고, 수신 측에서 처리 가능한 속도에 맞춰 메시지를 가져갈 수 있다.
  - 신뢰성: 메시지는 여러 가용 영역(AZ)에 중복 저장되어 유실 가능성이 매우 낮다.
- 주요 메커니즘 및 용어
  - 가시성 제한 시간 (Visibility Timeout)
    - 컨슈머가 큐에서 메시지를 가져간 후, 다른 컨슈머에게 해당 메시지가 보이지 않게 되는 시간이다.
    - 처리 중인 컨슈머가 실패할 경우, 이 시간이 지나면 메시지가 다시 큐에 나타나 다른 컨슈머가 처리할 수 있게 된다.
    - 처리가 완료되면 컨슈머는 명시적으로 메시지를 삭제해야 한다.
    - 처리량 자동 확장, 인프라 관리 불필요
  - 롱 폴링 (Long Polling)
    - Consumer가 큐가 비어있을 때 메시지가 들어올 때까지 일정 시간(최대 20초) 동안 기다리는 방식이다.
    - 빈 응답(Empty Response) 횟수를 줄여 비용을 절감하고 CPU 사용률을 낮춘다. 실무에서는 특별한 이유가 없다면 롱 폴링 사용이 권장된다.
  - 데드 레터 큐 (Dead Letter Queue, DLQ)
    - 여러 번 처리에 실패한 메시지를 따로 모아두는 격리용 큐다.
      - 잘못된 형식의 데이터나 처리 불가능한 '독약 메시지(Poison Message)'가 무한 반복되어 시스템 리소스를 낭비하는 것을 방지한다.
- SQS의 2가지 유형

| 구분 | 표준 대기열 (Standard Queue) | FIFO 대기열 (First-In-First-Out) |
|---|---|---|
| 처리량 | 무제한에 가까운 높은 처리량 | 초당 최대 3,000건 (배칭 시)으로 제한 |
| 순서 보장 | 보장되지 않음 (최선의 노력) | 엄격한 순서 보장 |
| 전달 횟수 | 최소 한 번 이상 (At-least-once) | 정확히 한 번 (Exactly-once) |
| 중복 발생 | 드물게 중복 메시지 발생 가능 | 중복 메시지 발생 안 함 |



## Amazon SNS (Simple Notification Service)


- 활용 구조

![구조](/assets/images/SNS.png)


- 분산 시스템, 마이크로서비스 및 서버리스 애플리케이션을 위한 완전 관리형 게시/구독(Pub/Sub) 메시징 서비스다.
- SQS가 메시지를 쌓아두는 '대기열'이라면, SNS는 메시지를 여러 수신처로 즉시 뿌려주는 '방송국'에 가깝다.
- 핵심 작동 원리: Pub/Sub 모델
  - 게시자 (Publisher): 특정 주제(Topic)로 메시지를 보낸다. 수신자가 누구인지, 몇 명인지 알 필요가 없다.
  - 주제 (Topic): 메시지가 전달되는 논리적 지점이자 커뮤니케이션 채널이다.
  - 구독자 (Subscriber): 주제를 구독하고 있는 대상들이다. 메시지가 게시되면 SNS가 각 구독자에게 메시지를 밀어넣기(Push) 방식으로 전달한다.
- 주요 프로토콜 (수신처)
  - SNS는 다양한 형태의 구독자를 지원한다.
  - 애플리케이션 엔드포인트: Amazon SQS, AWS Lambda, Amazon Kinesis Data Firehose, HTTP/S 웹훅.
  - 사용자 알림: 모바일 푸시 알림(APNs, FCM), SMS(문자 메시지), Email.
- 핵심 기능 및 패턴
  - 팬아웃 (Fan-out) 패턴
    - 하나의 메시지를 여러 SQS 큐나 Lambda 함수에 동시에 전달해야 할 때 사용한다. 예를 들어, 사용자가 결제를 완료하면 '결제 완료' 메시지를 SNS에 던지고, 이를 구독하는 '배송 시스템 큐'와 '이메일 발송 람다'가 각각 자신의 일을 처리하게 만든다.
  - 메시지 필터링 (Message Filtering)
    - 기본적으로 구독자는 주제에 게시된 모든 메시지를 받는다. 하지만 필터 정책을 설정하면, 특정 속성을 가진 메시지만 골라서 받도록 할 수 있다. (예: "로그 등급이 ERROR인 메시지만 이 큐로 보내줘")
  - 메시지 보안
    - IAM 정책: 누가 주제에 게시하고 누가 구독할 수 있는지 세밀하게 제어한다.
    - SSE (Server-Side Encryption): KMS를 사용하여 대기 중인 메시지를 암호화한다.


## Amazon Kinesis Data Streams (KDS)

- 수백만 개의 소스에서 초당 수조 개의 데이터를 실시간으로 수집하고 처리할 수 있는 서버리스 스트리밍 데이터 서비스다.
- KDS는 로그, 웹사이트 클릭스트림, IoT 데이터 등을 실시간으로 파이프라인에 태워 분석하거나 저장할 때 사용하는 핵심 도구다.
- 핵심 아키텍처 및 작동 원리
  - KDS는 크게 생성자(Producer), 스트림(Stream), 소비자(Consumer)로 구성된다.
  - 생성자: 데이터를 Kinesis로 보내는 주체다 (예: SDK, KPL, CloudWatch Logs, IoT 장치).
  - 스트림 (Stream): 데이터를 담고 있는 통로이며, 내부적으로 샤드(Shard)라는 단위로 쪼개져 있다.
  - 소비자 (Consumers): 데이터를 가져와서 처리하는 주체다 (예: Lambda, Kinesis Data Firehose, KCL 기반 커스텀 앱).
- 샤드(Shard)와 처리량 (Throughput)
  - KDS의 성능 단위는 샤드다. 스트림의 전체 성능은 보유한 샤드의 개수에 따라 결정된다.

| 구분 | 내용 |
|---|---|
| 작업 단위 | 샤드 1개당 성능 제한 |
| 데이터 입력 (Write) | 초당 1MB 또는 초당 1,000개의 레코드 |
| 데이터 출력 (Read) | 초당 2MB (모든 소비자 공유 기준) |

- 파티션 키 (Partition Key): 데이터를 특정 샤드에 할당하기 위해 사용하는 키다. 같은 키를 가진 데이터는 동일한 샤드로 들어가며, 샤드 내에서는 순서가 보장된다.

- Provisioned vs On-demand
  - Provisioned: 샤드 개수를 직접 지정한다. 트래픽 예측이 가능할 때 비용 효율적이다.
  - On-demand: AWS가 자동으로 성능을 조절한다. 트래픽 예측이 어려울 때 유리하다.

- 데이터 보존 (Retention)
  - 데이터는 스트림에 기본 24시간 동안 저장되며, 설정을 통해 최대 365일까지 연장할 수 있다.
  - SQS와 달리 소비자가 데이터를 읽어가도 데이터가 즉시 삭제되지 않으므로, 여러 소비자가 같은 데이터를 다시 읽거나(Replay) 각자 다른 방식으로 처리할 수 있다.


## Kinesis Data Firehose

- 스트리밍 데이터를 데이터 레이크, 데이터 웨어하우스, 분석 서비스로 로드하는 데 최적화된 완전 관리형 추출-변환-로드(ETL) 서비스이다.
- 핵심 작동 원리: 로드 및 변환
  - 수집 (Source): Kinesis Data Streams, CloudWatch Logs, IoT 서비스 또는 직접 SDK/API를 통해 데이터를 입력받는다.
  - 변환 (Transform): 데이터를 목적지에 저장하기 전에 AWS Lambda를 사용하여 실시간으로 데이터를 가공할 수 있다 (예: 특정 필드 삭제, 형식 변경).
  - 형식 변환 (Convert): JSON 형식의 데이터를 분석에 최적화된 Apache Parquet나 Apache ORC 형식으로 자동 변환하여 S3에 저장한다.
  - 전달 (Destination): S3, Redshift, OpenSearch 및 Splunk, Datadog과 같은 타사 서비스로 데이터를 전송한다.
- 주요 특징
  - 서버리스 (Serverless): 샤드(Shard) 관리나 프로비저닝이 전혀 필요 없다. 데이터 양에 따라 자동으로 크기가 조절된다.
  - Near Real-time: Kinesis Data Streams(실시간)와 달리, Firehose는 버퍼링(Buffering)을 사용한다. 설정된 시간(최소 60초) 또는 데이터 크기(최소 1MB)에 도달할 때까지 기다렸다가 한꺼번에 목적지로 보낸다.
  - 자동 재시도 및 백업: 목적지 전송에 실패할 경우 자동으로 재시도하며, 필요한 경우 모든 원본 데이터를 S3 버킷에 백업하도록 설정할 수 있다.

- Kinesis vs firehose

| 비교 항목 | Kinesis Data Streams (KDS) | Amazon Data Firehose |
|---|---|---|
| 속도 | 실시간 (70~200ms 미만) | 근실시간 (최소 60초 지연) |
| 관리 주체 | 사용자 (샤드 수 직접 관리) | AWS (완전 관리형 / 서버리스) |
| 데이터 보존 | 24시간 ~ 365일 저장 가능 | 저장 기능 없음 (즉시 전달) |
| 소비자 | Lambda, EC2 등 여러 소비자 가능 | 단일 목적지로 전달 |
| 주 용도 | 복잡한 실시간 처리 파이프라인 | 데이터 로드 및 간단한 ETL |



## Amazon MQ

- 클라우드에서 메시지 브로커를 간편하게 설정하고 운영할 수 있게 해주는 완전 관리형 메시지 브로커 서비스다.
- 기존 환경 그대로: 온프레미스에서 RabbitMQ나 ActiveMQ를 쓰던 애플리케이션을 AWS로 옮길 때, 코드를 SQS API에 맞춰서 새로 짜지 않고도 엔드포인트만 바꿔서 그대로 사용할 수 있다.
- 표준 프로토콜 지원: JMS(Java Message Service), AMQP, STOMP, MQTT, WebSocket 등 다양한 표준 프로토콜을 지원한다.